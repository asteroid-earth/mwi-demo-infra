// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessListHeader {
    /**
     * kind is a resource kind.
     */
    kind?: string;
    /**
     * metadata is resource metadata.
     */
    metadata?: outputs.AccessListHeaderMetadata;
    /**
     * sub_kind is an optional resource sub kind, used in some resources.
     */
    subKind?: string;
    /**
     * Version is the API version used to create the resource. It must be specified. Based on this version, Teleport will apply different defaults on resource creation or deletion. It must be an integer prefixed by "v". For example: `v1`
     */
    version: string;
}

export interface AccessListHeaderMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface AccessListSpec {
    /**
     * audit describes the frequency that this Access List must be audited.
     */
    audit: outputs.AccessListSpecAudit;
    /**
     * description is an optional plaintext description of the Access List.
     */
    description?: string;
    /**
     * grants describes the access granted by membership to this Access List.
     */
    grants: outputs.AccessListSpecGrants;
    /**
     * membership_requires describes the requirements for a user to be a member of the Access List. For a membership to an Access List to be effective, the user must meet the requirements of Membership_requires and must be in the members list.
     */
    membershipRequires?: outputs.AccessListSpecMembershipRequires;
    /**
     * owner_grants describes the access granted by owners to this Access List.
     */
    ownerGrants?: outputs.AccessListSpecOwnerGrants;
    /**
     * owners is a list of owners of the Access List.
     */
    owners: outputs.AccessListSpecOwner[];
    /**
     * ownership_requires describes the requirements for a user to be an owner of the Access List. For ownership of an Access List to be effective, the user must meet the requirements of ownership_requires and must be in the owners list.
     */
    ownershipRequires?: outputs.AccessListSpecOwnershipRequires;
    /**
     * title is a plaintext short description of the Access List.
     */
    title?: string;
}

export interface AccessListSpecAudit {
    /**
     * next_audit_date is when the next audit date should be done by.
     */
    nextAuditDate?: string;
    /**
     * notifications is the configuration for notifying users.
     */
    notifications?: outputs.AccessListSpecAuditNotifications;
    /**
     * recurrence is the recurrence definition
     */
    recurrence: outputs.AccessListSpecAuditRecurrence;
}

export interface AccessListSpecAuditNotifications {
    /**
     * start specifies when to start notifying users that the next audit date is coming up.
     */
    start?: string;
}

export interface AccessListSpecAuditRecurrence {
    /**
     * day_of_month is the day of month that reviews will be scheduled on. Supported values are 0, 1, 15, and 31.
     */
    dayOfMonth?: number;
    /**
     * frequency is the frequency of reviews. This represents the period in months between two reviews. Supported values are 0, 1, 3, 6, and 12.
     */
    frequency: number;
}

export interface AccessListSpecGrants {
    /**
     * roles are the roles that are granted to users who are members of the Access List.
     */
    roles?: string[];
    /**
     * traits are the traits that are granted to users who are members of the Access List.
     */
    traits?: outputs.AccessListSpecGrantsTrait[];
}

export interface AccessListSpecGrantsTrait {
    /**
     * key is the name of the trait.
     */
    key?: string;
    /**
     * values is the list of trait values.
     */
    values?: string[];
}

export interface AccessListSpecMembershipRequires {
    /**
     * roles are the user roles that must be present for the user to obtain access.
     */
    roles?: string[];
    /**
     * traits are the traits that must be present for the user to obtain access.
     */
    traits?: outputs.AccessListSpecMembershipRequiresTrait[];
}

export interface AccessListSpecMembershipRequiresTrait {
    /**
     * key is the name of the trait.
     */
    key?: string;
    /**
     * values is the list of trait values.
     */
    values?: string[];
}

export interface AccessListSpecOwner {
    /**
     * description is the plaintext description of the owner and why they are an owner.
     */
    description?: string;
    /**
     * membership_kind describes the type of membership, either `MEMBERSHIP_KIND_USER` or `MEMBERSHIP_KIND_LIST`.
     */
    membershipKind?: number;
    /**
     * name is the username of the owner.
     */
    name?: string;
}

export interface AccessListSpecOwnerGrants {
    /**
     * roles are the roles that are granted to users who are members of the Access List.
     */
    roles?: string[];
    /**
     * traits are the traits that are granted to users who are members of the Access List.
     */
    traits?: outputs.AccessListSpecOwnerGrantsTrait[];
}

export interface AccessListSpecOwnerGrantsTrait {
    /**
     * key is the name of the trait.
     */
    key?: string;
    /**
     * values is the list of trait values.
     */
    values?: string[];
}

export interface AccessListSpecOwnershipRequires {
    /**
     * roles are the user roles that must be present for the user to obtain access.
     */
    roles?: string[];
    /**
     * traits are the traits that must be present for the user to obtain access.
     */
    traits?: outputs.AccessListSpecOwnershipRequiresTrait[];
}

export interface AccessListSpecOwnershipRequiresTrait {
    /**
     * key is the name of the trait.
     */
    key?: string;
    /**
     * values is the list of trait values.
     */
    values?: string[];
}

export interface AccessMonitoringRuleMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface AccessMonitoringRuleSpec {
    /**
     * condition is a predicate expression that operates on the specified subject resources, and determines whether the subject will be moved into desired state.
     */
    condition?: string;
    /**
     * notification defines the plugin configuration for notifications if rule is triggered.
     */
    notification?: outputs.AccessMonitoringRuleSpecNotification;
    /**
     * states are the desired state which the monitoring rule is attempting to bring the subjects matching the condition to.
     */
    states?: string[];
    /**
     * subjects the rule operates on, can be a resource kind or a particular resource property.
     */
    subjects: string[];
}

export interface AccessMonitoringRuleSpecNotification {
    /**
     * name is the name of the plugin to which this configuration should apply.
     */
    name?: string;
    /**
     * recipients is the list of recipients the plugin should notify.
     */
    recipients?: string[];
}

export interface AppMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface AppSpec {
    /**
     * AWS contains additional options for AWS applications.
     */
    aws?: outputs.AppSpecAws;
    /**
     * Cloud identifies the cloud instance the app represents.
     */
    cloud?: string;
    /**
     * CORSPolicy defines the Cross-Origin Resource Sharing settings for the app.
     */
    cors?: outputs.AppSpecCors;
    /**
     * DynamicLabels are the app's command labels.
     */
    dynamicLabels?: {[key: string]: outputs.AppSpecDynamicLabels};
    /**
     * IdentityCenter encasulates AWS identity-center specific information. Only valid for Identity Center account apps.
     */
    identityCenter?: outputs.AppSpecIdentityCenter;
    /**
     * InsecureSkipVerify disables app's TLS certificate verification.
     */
    insecureSkipVerify?: boolean;
    /**
     * Integration is the integration name that must be used to access this Application. Only applicable to AWS App Access. If present, the Application must use the Integration's credentials instead of ambient credentials to access Cloud APIs.
     */
    integration?: string;
    /**
     * PublicAddr is the public address the application is accessible at.
     */
    publicAddr?: string;
    /**
     * RequiredAppNames is a list of app names that are required for this app to function. Any app listed here will be part of the authentication redirect flow and authenticate along side this app.
     */
    requiredAppNames?: string[];
    /**
     * Rewrite is a list of rewriting rules to apply to requests and responses.
     */
    rewrite?: outputs.AppSpecRewrite;
    /**
     * TCPPorts is a list of ports and port ranges that an app agent can forward connections to. Only applicable to TCP App Access. If this field is not empty, URI is expected to contain no port number and start with the tcp protocol.
     */
    tcpPorts?: outputs.AppSpecTcpPort[];
    /**
     * URI is the web app endpoint.
     */
    uri?: string;
    /**
     * UserGroups are a list of user group IDs that this app is associated with.
     */
    userGroups?: string[];
}

export interface AppSpecAws {
    /**
     * ExternalID is the AWS External ID used when assuming roles in this app.
     */
    externalId?: string;
}

export interface AppSpecCors {
    /**
     * allow_credentials indicates whether credentials are allowed.
     */
    allowCredentials?: boolean;
    /**
     * allowed_headers specifies which headers can be used when accessing the app.
     */
    allowedHeaders?: string[];
    /**
     * allowed_methods specifies which methods are allowed when accessing the app.
     */
    allowedMethods?: string[];
    /**
     * allowed_origins specifies which origins are allowed to access the app.
     */
    allowedOrigins?: string[];
    /**
     * exposed_headers indicates which headers are made available to scripts via the browser.
     */
    exposedHeaders?: string[];
    /**
     * max_age indicates how long (in seconds) the results of a preflight request can be cached.
     */
    maxAge?: number;
}

export interface AppSpecDynamicLabels {
    /**
     * Command is a command to run
     */
    commands?: string[];
    /**
     * Period is a time between command runs
     */
    period?: string;
    /**
     * Result captures standard output
     */
    result?: string;
}

export interface AppSpecIdentityCenter {
    /**
     * Account ID is the AWS-assigned ID of the account
     */
    accountId?: string;
    /**
     * PermissionSets lists the available permission sets on the given account
     */
    permissionSets?: outputs.AppSpecIdentityCenterPermissionSet[];
}

export interface AppSpecIdentityCenterPermissionSet {
    /**
     * ARN is the fully-formed ARN of the Permission Set.
     */
    arn?: string;
    /**
     * AssignmentID is the ID of the Teleport Account Assignment resource that represents this permission being assigned on the enclosing Account.
     */
    assignmentName?: string;
    /**
     * Name is the human-readable name of the Permission Set.
     */
    name?: string;
}

export interface AppSpecRewrite {
    /**
     * Headers is a list of headers to inject when passing the request over to the application.
     */
    headers?: outputs.AppSpecRewriteHeader[];
    /**
     * JWTClaims configures whether roles/traits are included in the JWT token.
     */
    jwtClaims?: string;
    /**
     * Redirect defines a list of hosts which will be rewritten to the public address of the application if they occur in the "Location" header.
     */
    redirects?: string[];
}

export interface AppSpecRewriteHeader {
    /**
     * Name is the http header name.
     */
    name?: string;
    /**
     * Value is the http header value.
     */
    value?: string;
}

export interface AppSpecTcpPort {
    /**
     * EndPort describes the end of the range, inclusive. If set, it must be between 2 and 65535 and be greater than Port when describing a port range. When omitted or set to zero, it signifies that the port range defines a single port.
     */
    endPort?: number;
    /**
     * Port describes the start of the range. It must be between 1 and 65535.
     */
    port?: number;
}

export interface AuthPreferenceMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels: {[key: string]: string};
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface AuthPreferenceSpec {
    /**
     * AllowHeadless enables/disables headless support. Headless authentication requires Webauthn to work. Defaults to true if the Webauthn is configured, defaults to false otherwise.
     */
    allowHeadless?: boolean;
    /**
     * AllowLocalAuth is true if local authentication is enabled.
     */
    allowLocalAuth?: boolean;
    /**
     * AllowPasswordless enables/disables passwordless support. Passwordless requires Webauthn to work. Defaults to true if the Webauthn is configured, defaults to false otherwise.
     */
    allowPasswordless?: boolean;
    /**
     * ConnectorName is the name of the OIDC or SAML connector. If this value is not set the first connector in the backend will be used.
     */
    connectorName?: string;
    /**
     * DefaultSessionTTL is the TTL to use for user certs when an explicit TTL is not requested.
     */
    defaultSessionTtl?: string;
    /**
     * DeviceTrust holds settings related to trusted device verification. Requires Teleport Enterprise.
     */
    deviceTrust?: outputs.AuthPreferenceSpecDeviceTrust;
    /**
     * DisconnectExpiredCert provides disconnect expired certificate setting - if true, connections with expired client certificates will get disconnected
     */
    disconnectExpiredCert?: boolean;
    /**
     * HardwareKey are the settings for hardware key support.
     */
    hardwareKey?: outputs.AuthPreferenceSpecHardwareKey;
    /**
     * IDP is a set of options related to accessing IdPs within Teleport. Requires Teleport Enterprise.
     */
    idp?: outputs.AuthPreferenceSpecIdp;
    /**
     * LockingMode is the cluster-wide locking mode default.
     */
    lockingMode: string;
    messageOfTheDay?: string;
    /**
     * Okta is a set of options related to the Okta service in Teleport. Requires Teleport Enterprise.
     */
    okta?: outputs.AuthPreferenceSpecOkta;
    /**
     * RequireMFAType is the type of MFA requirement enforced for this cluster. 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH", 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
     */
    requireSessionMfa?: number;
    /**
     * SecondFactor is the type of mult-factor. Deprecated: Prefer using SecondFactors instead.
     */
    secondFactor: string;
    /**
     * SecondFactors is a list of supported multi-factor types. 1 is "otp", 2 is "webauthn", 3 is "sso", If unspecified, the current default value is [1], or ["otp"].
     */
    secondFactors?: number[];
    /**
     * SignatureAlgorithmSuite is the configured signature algorithm suite for the cluster. If unspecified, the current default value is "legacy". 1 is "legacy", 2 is "balanced-v1", 3 is "fips-v1", 4 is "hsm-v1".
     */
    signatureAlgorithmSuite?: number;
    /**
     * StableUnixUserConfig contains the cluster-wide configuration for stable UNIX users.
     */
    stableUnixUserConfig?: outputs.AuthPreferenceSpecStableUnixUserConfig;
    /**
     * Type is the type of authentication.
     */
    type: string;
    /**
     * U2F are the settings for the U2F device.
     */
    u2f?: outputs.AuthPreferenceSpecU2f;
    /**
     * Webauthn are the settings for server-side Web Authentication support.
     */
    webauthn?: outputs.AuthPreferenceSpecWebauthn;
}

export interface AuthPreferenceSpecDeviceTrust {
    /**
     * Enable device auto-enroll. Auto-enroll lets any user issue a device enrollment token for a known device that is not already enrolled. `tsh` takes advantage of auto-enroll to automatically enroll devices on user login, when appropriate. The effective cluster Mode still applies: AutoEnroll=true is meaningless if Mode="off".
     */
    autoEnroll?: boolean;
    /**
     * Allow list of EKCert CAs in PEM format. If present, only TPM devices that present an EKCert that is signed by a CA specified here may be enrolled (existing enrollments are unchanged).  If not present, then the CA of TPM EKCerts will not be checked during enrollment, this allows any device to enroll.
     */
    ekcertAllowedCas?: string[];
    /**
     * Mode of verification for trusted devices.  The following modes are supported:  - "off": disables both device authentication and authorization. - "optional": allows both device authentication and authorization, but doesn't enforce the presence of device extensions for sensitive endpoints. - "required": enforces the presence of device extensions for sensitive endpoints.  Mode is always "off" for OSS. Defaults to "optional" for Enterprise.
     */
    mode?: string;
}

export interface AuthPreferenceSpecHardwareKey {
    /**
     * PinCacheTTL is the amount of time in nanoseconds that Teleport clients will cache the user's PIV PIN when hardware key PIN policy is enabled.
     */
    pinCacheTtl?: string;
    /**
     * PIVSlot is a PIV slot that Teleport clients should use instead of the default based on private key policy. For example, "9a" or "9e".
     */
    pivSlot?: string;
    /**
     * SerialNumberValidation holds settings for hardware key serial number validation. By default, serial number validation is disabled.
     */
    serialNumberValidation?: outputs.AuthPreferenceSpecHardwareKeySerialNumberValidation;
}

export interface AuthPreferenceSpecHardwareKeySerialNumberValidation {
    /**
     * Enabled indicates whether hardware key serial number validation is enabled.
     */
    enabled?: boolean;
    /**
     * SerialNumberTraitName is an optional custom user trait name for hardware key serial numbers to replace the default: "hardware_key_serial_numbers".  Note: Values for this user trait should be a comma-separated list of serial numbers, or a list of comm-separated lists. e.g ["123", "345,678"]
     */
    serialNumberTraitName?: string;
}

export interface AuthPreferenceSpecIdp {
    /**
     * SAML are options related to the Teleport SAML IdP.
     */
    saml?: outputs.AuthPreferenceSpecIdpSaml;
}

export interface AuthPreferenceSpecIdpSaml {
    /**
     * Enabled is set to true if this option allows access to the Teleport SAML IdP.
     */
    enabled?: boolean;
}

export interface AuthPreferenceSpecOkta {
    /**
     * SyncPeriod is the duration between synchronization calls in nanoseconds.
     */
    syncPeriod?: string;
}

export interface AuthPreferenceSpecStableUnixUserConfig {
    /**
     * Enabled signifies that (UNIX) Teleport SSH hosts should obtain a UID from the control plane if they're about to provision a host user with no other configured UID.
     */
    enabled?: boolean;
    /**
     * FirstUid is the start of the range of UIDs for autoprovisioned host users. The range is inclusive on both ends, so the specified UID can be assigned.
     */
    firstUid?: number;
    /**
     * LastUid is the end of the range of UIDs for autoprovisioned host users. The range is inclusive on both ends, so the specified UID can be assigned.
     */
    lastUid?: number;
}

export interface AuthPreferenceSpecU2f {
    /**
     * AppID returns the application ID for universal mult-factor.
     */
    appId?: string;
    /**
     * DeviceAttestationCAs contains the trusted attestation CAs for U2F devices.
     */
    deviceAttestationCas?: string[];
    /**
     * Facets returns the facets for universal mult-factor. Deprecated: Kept for backwards compatibility reasons, but Facets have no effect since Teleport v10, when Webauthn replaced the U2F implementation.
     */
    facets?: string[];
}

export interface AuthPreferenceSpecWebauthn {
    /**
     * Allow list of device attestation CAs in PEM format. If present, only devices whose attestation certificates match the certificates specified here may be registered (existing registrations are unchanged). If supplied in conjunction with AttestationDeniedCAs, then both conditions need to be true for registration to be allowed (the device MUST match an allowed CA and MUST NOT match a denied CA). By default all devices are allowed.
     */
    attestationAllowedCas?: string[];
    /**
     * Deny list of device attestation CAs in PEM format. If present, only devices whose attestation certificates don't match the certificates specified here may be registered (existing registrations are unchanged). If supplied in conjunction with AttestationAllowedCAs, then both conditions need to be true for registration to be allowed (the device MUST match an allowed CA and MUST NOT match a denied CA). By default no devices are denied.
     */
    attestationDeniedCas?: string[];
    /**
     * RPID is the ID of the Relying Party. It should be set to the domain name of the Teleport installation.  IMPORTANT: RPID must never change in the lifetime of the cluster, because it's recorded in the registration data on the WebAuthn device. If the RPID changes, all existing WebAuthn key registrations will become invalid and all users who use WebAuthn as the multi-factor will need to re-register.
     */
    rpId?: string;
}

export interface AutoupdateConfigMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface AutoupdateConfigSpec {
    agents?: outputs.AutoupdateConfigSpecAgents;
    tools?: outputs.AutoupdateConfigSpecTools;
}

export interface AutoupdateConfigSpecAgents {
    /**
     * maintenance_window_duration is the maintenance window duration. This can only be set if `strategy` is "time-based". Once the window is over, the group transitions to the done state. Existing agents won't be updated until the next maintenance window.
     */
    maintenanceWindowDuration?: string;
    /**
     * mode specifies whether agent autoupdates are enabled, disabled, or paused.
     */
    mode?: string;
    /**
     * schedules specifies schedules for updates of grouped agents.
     */
    schedules?: outputs.AutoupdateConfigSpecAgentsSchedules;
    /**
     * strategy to use for updating the agents.
     */
    strategy?: string;
}

export interface AutoupdateConfigSpecAgentsSchedules {
    /**
     * regular schedules for non-critical versions.
     */
    regulars?: outputs.AutoupdateConfigSpecAgentsSchedulesRegular[];
}

export interface AutoupdateConfigSpecAgentsSchedulesRegular {
    /**
     * days when the update can run. Supported values are "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" and "*"
     */
    days?: string[];
    /**
     * name of the group
     */
    name?: string;
    /**
     * start_hour to initiate update
     */
    startHour?: number;
    /**
     * wait_hours after last group succeeds before this group can run. This can only be used when the strategy is "halt-on-failure". This field must be positive.
     */
    waitHours?: number;
}

export interface AutoupdateConfigSpecTools {
    /**
     * Mode defines state of the client tools auto update.
     */
    mode?: string;
}

export interface AutoupdateVersionMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface AutoupdateVersionSpec {
    agents?: outputs.AutoupdateVersionSpecAgents;
    tools?: outputs.AutoupdateVersionSpecTools;
}

export interface AutoupdateVersionSpecAgents {
    /**
     * autoupdate_mode to use for the rollout
     */
    mode?: string;
    /**
     * schedule to use for the rollout
     */
    schedule?: string;
    /**
     * start_version is the version to update from.
     */
    startVersion?: string;
    /**
     * target_version is the version to update to.
     */
    targetVersion?: string;
}

export interface AutoupdateVersionSpecTools {
    /**
     * TargetVersion specifies the semantic version required for tools to establish a connection with the cluster. Client tools after connection to the cluster going to be updated to this version automatically.
     */
    targetVersion?: string;
}

export interface ClusterMaintenanceConfigMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface ClusterMaintenanceConfigSpec {
    /**
     * AgentUpgrades encodes the agent upgrade window.
     */
    agentUpgrades?: outputs.ClusterMaintenanceConfigSpecAgentUpgrades;
}

export interface ClusterMaintenanceConfigSpecAgentUpgrades {
    /**
     * UTCStartHour is the start hour of the maintenance window in UTC.
     */
    utcStartHour?: number;
    /**
     * Weekdays is an optional list of weekdays. If not specified, an agent upgrade window occurs every day.
     */
    weekdays?: string[];
}

export interface ClusterNetworkingConfigMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface ClusterNetworkingConfigSpec {
    /**
     * AssistCommandExecutionWorkers determines the number of workers that will execute arbitrary Assist commands on servers in parallel
     */
    assistCommandExecutionWorkers?: number;
    /**
     * CaseInsensitiveRouting causes proxies to use case-insensitive hostname matching.
     */
    caseInsensitiveRouting?: boolean;
    /**
     * ClientIdleTimeout sets global cluster default setting for client idle timeouts.
     */
    clientIdleTimeout?: string;
    /**
     * ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
     */
    idleTimeoutMessage?: string;
    /**
     * KeepAliveCountMax is the number of keep-alive messages that can be missed before the server disconnects the connection to the client.
     */
    keepAliveCountMax: number;
    /**
     * KeepAliveInterval is the interval at which the server sends keep-alive messages to the client.
     */
    keepAliveInterval: string;
    /**
     * ProxyListenerMode is proxy listener mode used by Teleport Proxies. 0 is "separate"; 1 is "multiplex".
     */
    proxyListenerMode?: number;
    /**
     * ProxyPingInterval defines in which interval the TLS routing ping message should be sent. This is applicable only when using ping-wrapped connections, regular TLS routing connections are not affected.
     */
    proxyPingInterval?: string;
    /**
     * RoutingStrategy determines the strategy used to route to nodes. 0 is "unambiguous_match"; 1 is "most_recent".
     */
    routingStrategy?: number;
    /**
     * SessionControlTimeout is the session control lease expiry and defines the upper limit of how long a node may be out of contact with the auth server before it begins terminating controlled sessions.
     */
    sessionControlTimeout?: string;
    /**
     * SSHDialTimeout is a custom dial timeout used when establishing SSH connections. If not set, the default timeout of 30s will be used.
     */
    sshDialTimeout?: string;
    /**
     * TunnelStrategyV1 determines the tunnel strategy used in the cluster.
     */
    tunnelStrategy?: outputs.ClusterNetworkingConfigSpecTunnelStrategy;
    /**
     * WebIdleTimeout sets global cluster default setting for the web UI idle timeouts.
     */
    webIdleTimeout?: string;
}

export interface ClusterNetworkingConfigSpecTunnelStrategy {
    agentMesh?: outputs.ClusterNetworkingConfigSpecTunnelStrategyAgentMesh;
    proxyPeering?: outputs.ClusterNetworkingConfigSpecTunnelStrategyProxyPeering;
}

export interface ClusterNetworkingConfigSpecTunnelStrategyAgentMesh {
    /**
     * Automatically generated field preventing empty message errors
     */
    active: boolean;
}

export interface ClusterNetworkingConfigSpecTunnelStrategyProxyPeering {
    agentConnectionCount?: number;
}

export interface DatabaseMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface DatabaseSpec {
    /**
     * AD is the Active Directory configuration for the database.
     */
    ad?: outputs.DatabaseSpecAd;
    /**
     * AdminUser is the database admin user for automatic user provisioning.
     */
    adminUser?: outputs.DatabaseSpecAdminUser;
    /**
     * AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
     */
    aws?: outputs.DatabaseSpecAws;
    /**
     * Azure contains Azure specific database metadata.
     */
    azure?: outputs.DatabaseSpecAzure;
    /**
     * CACert is the PEM-encoded database CA certificate.  DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.
     */
    caCert?: string;
    /**
     * DynamicLabels is the database dynamic labels.
     */
    dynamicLabels?: {[key: string]: outputs.DatabaseSpecDynamicLabels};
    /**
     * GCP contains parameters specific to GCP Cloud SQL databases.
     */
    gcp?: outputs.DatabaseSpecGcp;
    /**
     * MongoAtlas contains Atlas metadata about the database.
     */
    mongoAtlas?: outputs.DatabaseSpecMongoAtlas;
    /**
     * MySQL is an additional section with MySQL database options.
     */
    mysql?: outputs.DatabaseSpecMysql;
    /**
     * Oracle is an additional Oracle configuration options.
     */
    oracle?: outputs.DatabaseSpecOracle;
    /**
     * Protocol is the database protocol: postgres, mysql, mongodb, etc.
     */
    protocol: string;
    /**
     * TLS is the TLS configuration used when establishing connection to target database. Allows to provide custom CA cert or override server name.
     */
    tls?: outputs.DatabaseSpecTls;
    /**
     * URI is the database connection endpoint.
     */
    uri: string;
}

export interface DatabaseSpecAd {
    /**
     * Domain is the Active Directory domain the database resides in.
     */
    domain?: string;
    /**
     * KDCHostName is the host name for a KDC for x509 Authentication.
     */
    kdcHostName?: string;
    /**
     * KeytabFile is the path to the Kerberos keytab file.
     */
    keytabFile?: string;
    /**
     * Krb5File is the path to the Kerberos configuration file. Defaults to /etc/krb5.conf.
     */
    krb5File?: string;
    /**
     * LDAPCert is a certificate from Windows LDAP/AD, optional; only for x509 Authentication.
     */
    ldapCert?: string;
    /**
     * SPN is the service principal name for the database.
     */
    spn?: string;
}

export interface DatabaseSpecAdminUser {
    /**
     * DefaultDatabase is the database that the privileged database user logs into by default.  Depending on the database type, this database may be used to store procedures or data for managing database users.
     */
    defaultDatabase?: string;
    /**
     * Name is the username of the privileged database user.
     */
    name?: string;
}

export interface DatabaseSpecAws {
    /**
     * AccountID is the AWS account ID this database belongs to.
     */
    accountId?: string;
    /**
     * AssumeRoleARN is an optional AWS role ARN to assume when accessing a database. Set this field and ExternalID to enable access across AWS accounts.
     */
    assumeRoleArn?: string;
    /**
     * DocumentDB contains AWS DocumentDB specific metadata.
     */
    docdb?: outputs.DatabaseSpecAwsDocdb;
    /**
     * ElastiCache contains AWS ElastiCache Redis specific metadata.
     */
    elasticache?: outputs.DatabaseSpecAwsElasticache;
    /**
     * ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
     */
    externalId?: string;
    /**
     * IAMPolicyStatus indicates whether the IAM Policy is configured properly for database access. If not, the user must update the AWS profile identity to allow access to the Database. Eg for an RDS Database: the underlying AWS profile allows for `rds-db:connect` for the Database.
     */
    iamPolicyStatus?: number;
    /**
     * MemoryDB contains AWS MemoryDB specific metadata.
     */
    memorydb?: outputs.DatabaseSpecAwsMemorydb;
    /**
     * OpenSearch contains AWS OpenSearch specific metadata.
     */
    opensearch?: outputs.DatabaseSpecAwsOpensearch;
    /**
     * RDS contains RDS specific metadata.
     */
    rds?: outputs.DatabaseSpecAwsRds;
    /**
     * RDSProxy contains AWS Proxy specific metadata.
     */
    rdsproxy?: outputs.DatabaseSpecAwsRdsproxy;
    /**
     * Redshift contains Redshift specific metadata.
     */
    redshift?: outputs.DatabaseSpecAwsRedshift;
    /**
     * RedshiftServerless contains AWS Redshift Serverless specific metadata.
     */
    redshiftServerless?: outputs.DatabaseSpecAwsRedshiftServerless;
    /**
     * Region is a AWS cloud region.
     */
    region?: string;
    /**
     * SecretStore contains secret store configurations.
     */
    secretStore?: outputs.DatabaseSpecAwsSecretStore;
    /**
     * SessionTags is a list of AWS STS session tags.
     */
    sessionTags?: {[key: string]: string};
}

export interface DatabaseSpecAwsDocdb {
    /**
     * ClusterID is the cluster identifier.
     */
    clusterId?: string;
    /**
     * EndpointType is the type of the endpoint.
     */
    endpointType?: string;
    /**
     * InstanceID is the instance identifier.
     */
    instanceId?: string;
}

export interface DatabaseSpecAwsElasticache {
    /**
     * EndpointType is the type of the endpoint.
     */
    endpointType?: string;
    /**
     * ReplicationGroupID is the Redis replication group ID.
     */
    replicationGroupId?: string;
    /**
     * TransitEncryptionEnabled indicates whether in-transit encryption (TLS) is enabled.
     */
    transitEncryptionEnabled?: boolean;
    /**
     * UserGroupIDs is a list of user group IDs.
     */
    userGroupIds?: string[];
}

export interface DatabaseSpecAwsMemorydb {
    /**
     * ACLName is the name of the ACL associated with the cluster.
     */
    aclName?: string;
    /**
     * ClusterName is the name of the MemoryDB cluster.
     */
    clusterName?: string;
    /**
     * EndpointType is the type of the endpoint.
     */
    endpointType?: string;
    /**
     * TLSEnabled indicates whether in-transit encryption (TLS) is enabled.
     */
    tlsEnabled?: boolean;
}

export interface DatabaseSpecAwsOpensearch {
    /**
     * DomainID is the ID of the domain.
     */
    domainId?: string;
    /**
     * DomainName is the name of the domain.
     */
    domainName?: string;
    /**
     * EndpointType is the type of the endpoint.
     */
    endpointType?: string;
}

export interface DatabaseSpecAwsRds {
    /**
     * ClusterID is the RDS cluster (Aurora) identifier.
     */
    clusterId?: string;
    /**
     * IAMAuth indicates whether database IAM authentication is enabled.
     */
    iamAuth?: boolean;
    /**
     * InstanceID is the RDS instance identifier.
     */
    instanceId?: string;
    /**
     * ResourceID is the RDS instance resource identifier (db-xxx).
     */
    resourceId?: string;
    /**
     * SecurityGroups is a list of attached security groups for the RDS instance.
     */
    securityGroups?: string[];
    /**
     * Subnets is a list of subnets for the RDS instance.
     */
    subnets?: string[];
    /**
     * VPCID is the VPC where the RDS is running.
     */
    vpcId?: string;
}

export interface DatabaseSpecAwsRdsproxy {
    /**
     * CustomEndpointName is the identifier of an RDS Proxy custom endpoint.
     */
    customEndpointName?: string;
    /**
     * Name is the identifier of an RDS Proxy.
     */
    name?: string;
    /**
     * ResourceID is the RDS instance resource identifier (prx-xxx).
     */
    resourceId?: string;
}

export interface DatabaseSpecAwsRedshift {
    /**
     * ClusterID is the Redshift cluster identifier.
     */
    clusterId?: string;
}

export interface DatabaseSpecAwsRedshiftServerless {
    /**
     * EndpointName is the VPC endpoint name.
     */
    endpointName?: string;
    /**
     * WorkgroupID is the workgroup ID.
     */
    workgroupId?: string;
    /**
     * WorkgroupName is the workgroup name.
     */
    workgroupName?: string;
}

export interface DatabaseSpecAwsSecretStore {
    /**
     * KeyPrefix specifies the secret key prefix.
     */
    keyPrefix?: string;
    /**
     * KMSKeyID specifies the AWS KMS key for encryption.
     */
    kmsKeyId?: string;
}

export interface DatabaseSpecAzure {
    /**
     * IsFlexiServer is true if the database is an Azure Flexible server.
     */
    isFlexiServer?: boolean;
    /**
     * Name is the Azure database server name.
     */
    name?: string;
    /**
     * Redis contains Azure Cache for Redis specific database metadata.
     */
    redis?: outputs.DatabaseSpecAzureRedis;
    /**
     * ResourceID is the Azure fully qualified ID for the resource.
     */
    resourceId?: string;
}

export interface DatabaseSpecAzureRedis {
    /**
     * ClusteringPolicy is the clustering policy for Redis Enterprise.
     */
    clusteringPolicy?: string;
}

export interface DatabaseSpecDynamicLabels {
    /**
     * Command is a command to run
     */
    commands?: string[];
    /**
     * Period is a time between command runs
     */
    period?: string;
    /**
     * Result captures standard output
     */
    result?: string;
}

export interface DatabaseSpecGcp {
    /**
     * InstanceID is the Cloud SQL instance ID.
     */
    instanceId?: string;
    /**
     * ProjectID is the GCP project ID the Cloud SQL instance resides in.
     */
    projectId?: string;
}

export interface DatabaseSpecMongoAtlas {
    /**
     * Name is the Atlas database instance name.
     */
    name?: string;
}

export interface DatabaseSpecMysql {
    /**
     * ServerVersion is the server version reported by DB proxy if the runtime information is not available.
     */
    serverVersion?: string;
}

export interface DatabaseSpecOracle {
    /**
     * AuditUser is the Oracle database user privilege to access internal Oracle audit trail.
     */
    auditUser?: string;
}

export interface DatabaseSpecTls {
    /**
     * CACert is an optional user provided CA certificate used for verifying database TLS connection.
     */
    caCert?: string;
    /**
     * Mode is a TLS connection mode. 0 is "verify-full"; 1 is "verify-ca", 2 is "insecure".
     */
    mode?: number;
    /**
     * ServerName allows to provide custom hostname. This value will override the servername/hostname on a certificate during validation.
     */
    serverName?: string;
    /**
     * TrustSystemCertPool allows Teleport to trust certificate authorities available on the host system. If not set (by default), Teleport only trusts self-signed databases with TLS certificates signed by Teleport's Database Server CA or the ca_cert specified in this TLS setting. For cloud-hosted databases, Teleport downloads the corresponding required CAs for validation.
     */
    trustSystemCertPool?: boolean;
}

export interface DynamicWindowsDesktopMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface DynamicWindowsDesktopSpec {
    /**
     * Addr is the address that this host can be reached at.
     */
    addr: string;
    /**
     * Domain is the ActiveDirectory domain that this host belongs to.
     */
    domain?: string;
    /**
     * NonAD marks this desktop as a standalone host that is not joined to an Active Directory domain.
     */
    nonAd?: boolean;
    /**
     * ScreenSize specifies the size of the screen to use for sessions on this host. In most cases this should be unspecified, in which case Teleport will fill the browser window.
     */
    screenSize?: outputs.DynamicWindowsDesktopSpecScreenSize;
}

export interface DynamicWindowsDesktopSpecScreenSize {
    height?: number;
    width?: number;
}

export interface GetAccessListHeader {
    /**
     * kind is a resource kind.
     */
    kind?: string;
    /**
     * metadata is resource metadata.
     */
    metadata?: outputs.GetAccessListHeaderMetadata;
    /**
     * sub_kind is an optional resource sub kind, used in some resources.
     */
    subKind?: string;
    /**
     * Version is the API version used to create the resource. It must be specified. Based on this version, Teleport will apply different defaults on resource creation or deletion. It must be an integer prefixed by "v". For example: `v1`
     */
    version: string;
}

export interface GetAccessListHeaderMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetAccessListSpec {
    /**
     * audit describes the frequency that this Access List must be audited.
     */
    audit: outputs.GetAccessListSpecAudit;
    /**
     * description is an optional plaintext description of the Access List.
     */
    description?: string;
    /**
     * grants describes the access granted by membership to this Access List.
     */
    grants: outputs.GetAccessListSpecGrants;
    /**
     * membership_requires describes the requirements for a user to be a member of the Access List. For a membership to an Access List to be effective, the user must meet the requirements of Membership_requires and must be in the members list.
     */
    membershipRequires?: outputs.GetAccessListSpecMembershipRequires;
    /**
     * owner_grants describes the access granted by owners to this Access List.
     */
    ownerGrants?: outputs.GetAccessListSpecOwnerGrants;
    /**
     * owners is a list of owners of the Access List.
     */
    owners: outputs.GetAccessListSpecOwner[];
    /**
     * ownership_requires describes the requirements for a user to be an owner of the Access List. For ownership of an Access List to be effective, the user must meet the requirements of ownership_requires and must be in the owners list.
     */
    ownershipRequires?: outputs.GetAccessListSpecOwnershipRequires;
    /**
     * title is a plaintext short description of the Access List.
     */
    title?: string;
}

export interface GetAccessListSpecAudit {
    /**
     * next_audit_date is when the next audit date should be done by.
     */
    nextAuditDate?: string;
    /**
     * notifications is the configuration for notifying users.
     */
    notifications?: outputs.GetAccessListSpecAuditNotifications;
    /**
     * recurrence is the recurrence definition
     */
    recurrence: outputs.GetAccessListSpecAuditRecurrence;
}

export interface GetAccessListSpecAuditNotifications {
    /**
     * start specifies when to start notifying users that the next audit date is coming up.
     */
    start?: string;
}

export interface GetAccessListSpecAuditRecurrence {
    /**
     * day_of_month is the day of month that reviews will be scheduled on. Supported values are 0, 1, 15, and 31.
     */
    dayOfMonth?: number;
    /**
     * frequency is the frequency of reviews. This represents the period in months between two reviews. Supported values are 0, 1, 3, 6, and 12.
     */
    frequency: number;
}

export interface GetAccessListSpecGrants {
    /**
     * roles are the roles that are granted to users who are members of the Access List.
     */
    roles?: string[];
    /**
     * traits are the traits that are granted to users who are members of the Access List.
     */
    traits?: outputs.GetAccessListSpecGrantsTrait[];
}

export interface GetAccessListSpecGrantsTrait {
    /**
     * key is the name of the trait.
     */
    key?: string;
    /**
     * values is the list of trait values.
     */
    values?: string[];
}

export interface GetAccessListSpecMembershipRequires {
    /**
     * roles are the user roles that must be present for the user to obtain access.
     */
    roles?: string[];
    /**
     * traits are the traits that must be present for the user to obtain access.
     */
    traits?: outputs.GetAccessListSpecMembershipRequiresTrait[];
}

export interface GetAccessListSpecMembershipRequiresTrait {
    /**
     * key is the name of the trait.
     */
    key?: string;
    /**
     * values is the list of trait values.
     */
    values?: string[];
}

export interface GetAccessListSpecOwner {
    /**
     * description is the plaintext description of the owner and why they are an owner.
     */
    description?: string;
    /**
     * membership_kind describes the type of membership, either `MEMBERSHIP_KIND_USER` or `MEMBERSHIP_KIND_LIST`.
     */
    membershipKind?: number;
    /**
     * name is the username of the owner.
     */
    name?: string;
}

export interface GetAccessListSpecOwnerGrants {
    /**
     * roles are the roles that are granted to users who are members of the Access List.
     */
    roles?: string[];
    /**
     * traits are the traits that are granted to users who are members of the Access List.
     */
    traits?: outputs.GetAccessListSpecOwnerGrantsTrait[];
}

export interface GetAccessListSpecOwnerGrantsTrait {
    /**
     * key is the name of the trait.
     */
    key?: string;
    /**
     * values is the list of trait values.
     */
    values?: string[];
}

export interface GetAccessListSpecOwnershipRequires {
    /**
     * roles are the user roles that must be present for the user to obtain access.
     */
    roles?: string[];
    /**
     * traits are the traits that must be present for the user to obtain access.
     */
    traits?: outputs.GetAccessListSpecOwnershipRequiresTrait[];
}

export interface GetAccessListSpecOwnershipRequiresTrait {
    /**
     * key is the name of the trait.
     */
    key?: string;
    /**
     * values is the list of trait values.
     */
    values?: string[];
}

export interface GetAccessMonitoringRuleMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetAccessMonitoringRuleSpec {
    /**
     * condition is a predicate expression that operates on the specified subject resources, and determines whether the subject will be moved into desired state.
     */
    condition?: string;
    /**
     * notification defines the plugin configuration for notifications if rule is triggered.
     */
    notification?: outputs.GetAccessMonitoringRuleSpecNotification;
    /**
     * states are the desired state which the monitoring rule is attempting to bring the subjects matching the condition to.
     */
    states?: string[];
    /**
     * subjects the rule operates on, can be a resource kind or a particular resource property.
     */
    subjects: string[];
}

export interface GetAccessMonitoringRuleSpecNotification {
    /**
     * name is the name of the plugin to which this configuration should apply.
     */
    name?: string;
    /**
     * recipients is the list of recipients the plugin should notify.
     */
    recipients?: string[];
}

export interface GetAppMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetAppSpec {
    /**
     * AWS contains additional options for AWS applications.
     */
    aws?: outputs.GetAppSpecAws;
    /**
     * Cloud identifies the cloud instance the app represents.
     */
    cloud?: string;
    /**
     * CORSPolicy defines the Cross-Origin Resource Sharing settings for the app.
     */
    cors?: outputs.GetAppSpecCors;
    /**
     * DynamicLabels are the app's command labels.
     */
    dynamicLabels?: {[key: string]: outputs.GetAppSpecDynamicLabels};
    /**
     * IdentityCenter encasulates AWS identity-center specific information. Only valid for Identity Center account apps.
     */
    identityCenter?: outputs.GetAppSpecIdentityCenter;
    /**
     * InsecureSkipVerify disables app's TLS certificate verification.
     */
    insecureSkipVerify?: boolean;
    /**
     * Integration is the integration name that must be used to access this Application. Only applicable to AWS App Access. If present, the Application must use the Integration's credentials instead of ambient credentials to access Cloud APIs.
     */
    integration?: string;
    /**
     * PublicAddr is the public address the application is accessible at.
     */
    publicAddr?: string;
    /**
     * RequiredAppNames is a list of app names that are required for this app to function. Any app listed here will be part of the authentication redirect flow and authenticate along side this app.
     */
    requiredAppNames?: string[];
    /**
     * Rewrite is a list of rewriting rules to apply to requests and responses.
     */
    rewrite?: outputs.GetAppSpecRewrite;
    /**
     * TCPPorts is a list of ports and port ranges that an app agent can forward connections to. Only applicable to TCP App Access. If this field is not empty, URI is expected to contain no port number and start with the tcp protocol.
     */
    tcpPorts?: outputs.GetAppSpecTcpPort[];
    /**
     * URI is the web app endpoint.
     */
    uri?: string;
    /**
     * UserGroups are a list of user group IDs that this app is associated with.
     */
    userGroups?: string[];
}

export interface GetAppSpecAws {
    /**
     * ExternalID is the AWS External ID used when assuming roles in this app.
     */
    externalId?: string;
}

export interface GetAppSpecCors {
    /**
     * allow_credentials indicates whether credentials are allowed.
     */
    allowCredentials?: boolean;
    /**
     * allowed_headers specifies which headers can be used when accessing the app.
     */
    allowedHeaders?: string[];
    /**
     * allowed_methods specifies which methods are allowed when accessing the app.
     */
    allowedMethods?: string[];
    /**
     * allowed_origins specifies which origins are allowed to access the app.
     */
    allowedOrigins?: string[];
    /**
     * exposed_headers indicates which headers are made available to scripts via the browser.
     */
    exposedHeaders?: string[];
    /**
     * max_age indicates how long (in seconds) the results of a preflight request can be cached.
     */
    maxAge?: number;
}

export interface GetAppSpecDynamicLabels {
    /**
     * Command is a command to run
     */
    commands?: string[];
    /**
     * Period is a time between command runs
     */
    period?: string;
    /**
     * Result captures standard output
     */
    result?: string;
}

export interface GetAppSpecIdentityCenter {
    /**
     * Account ID is the AWS-assigned ID of the account
     */
    accountId?: string;
    /**
     * PermissionSets lists the available permission sets on the given account
     */
    permissionSets?: outputs.GetAppSpecIdentityCenterPermissionSet[];
}

export interface GetAppSpecIdentityCenterPermissionSet {
    /**
     * ARN is the fully-formed ARN of the Permission Set.
     */
    arn?: string;
    /**
     * AssignmentID is the ID of the Teleport Account Assignment resource that represents this permission being assigned on the enclosing Account.
     */
    assignmentName?: string;
    /**
     * Name is the human-readable name of the Permission Set.
     */
    name?: string;
}

export interface GetAppSpecRewrite {
    /**
     * Headers is a list of headers to inject when passing the request over to the application.
     */
    headers?: outputs.GetAppSpecRewriteHeader[];
    /**
     * JWTClaims configures whether roles/traits are included in the JWT token.
     */
    jwtClaims?: string;
    /**
     * Redirect defines a list of hosts which will be rewritten to the public address of the application if they occur in the "Location" header.
     */
    redirects?: string[];
}

export interface GetAppSpecRewriteHeader {
    /**
     * Name is the http header name.
     */
    name?: string;
    /**
     * Value is the http header value.
     */
    value?: string;
}

export interface GetAppSpecTcpPort {
    /**
     * EndPort describes the end of the range, inclusive. If set, it must be between 2 and 65535 and be greater than Port when describing a port range. When omitted or set to zero, it signifies that the port range defines a single port.
     */
    endPort?: number;
    /**
     * Port describes the start of the range. It must be between 1 and 65535.
     */
    port?: number;
}

export interface GetAuthPreferenceMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels: {[key: string]: string};
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetAuthPreferenceSpec {
    /**
     * AllowHeadless enables/disables headless support. Headless authentication requires Webauthn to work. Defaults to true if the Webauthn is configured, defaults to false otherwise.
     */
    allowHeadless?: boolean;
    /**
     * AllowLocalAuth is true if local authentication is enabled.
     */
    allowLocalAuth?: boolean;
    /**
     * AllowPasswordless enables/disables passwordless support. Passwordless requires Webauthn to work. Defaults to true if the Webauthn is configured, defaults to false otherwise.
     */
    allowPasswordless?: boolean;
    /**
     * ConnectorName is the name of the OIDC or SAML connector. If this value is not set the first connector in the backend will be used.
     */
    connectorName?: string;
    /**
     * DefaultSessionTTL is the TTL to use for user certs when an explicit TTL is not requested.
     */
    defaultSessionTtl?: string;
    /**
     * DeviceTrust holds settings related to trusted device verification. Requires Teleport Enterprise.
     */
    deviceTrust?: outputs.GetAuthPreferenceSpecDeviceTrust;
    /**
     * DisconnectExpiredCert provides disconnect expired certificate setting - if true, connections with expired client certificates will get disconnected
     */
    disconnectExpiredCert?: boolean;
    /**
     * HardwareKey are the settings for hardware key support.
     */
    hardwareKey?: outputs.GetAuthPreferenceSpecHardwareKey;
    /**
     * IDP is a set of options related to accessing IdPs within Teleport. Requires Teleport Enterprise.
     */
    idp?: outputs.GetAuthPreferenceSpecIdp;
    /**
     * LockingMode is the cluster-wide locking mode default.
     */
    lockingMode: string;
    messageOfTheDay?: string;
    /**
     * Okta is a set of options related to the Okta service in Teleport. Requires Teleport Enterprise.
     */
    okta?: outputs.GetAuthPreferenceSpecOkta;
    /**
     * RequireMFAType is the type of MFA requirement enforced for this cluster. 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH", 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
     */
    requireSessionMfa?: number;
    /**
     * SecondFactor is the type of mult-factor. Deprecated: Prefer using SecondFactors instead.
     */
    secondFactor: string;
    /**
     * SecondFactors is a list of supported multi-factor types. 1 is "otp", 2 is "webauthn", 3 is "sso", If unspecified, the current default value is [1], or ["otp"].
     */
    secondFactors?: number[];
    /**
     * SignatureAlgorithmSuite is the configured signature algorithm suite for the cluster. If unspecified, the current default value is "legacy". 1 is "legacy", 2 is "balanced-v1", 3 is "fips-v1", 4 is "hsm-v1".
     */
    signatureAlgorithmSuite?: number;
    /**
     * StableUnixUserConfig contains the cluster-wide configuration for stable UNIX users.
     */
    stableUnixUserConfig?: outputs.GetAuthPreferenceSpecStableUnixUserConfig;
    /**
     * Type is the type of authentication.
     */
    type: string;
    /**
     * U2F are the settings for the U2F device.
     */
    u2f?: outputs.GetAuthPreferenceSpecU2f;
    /**
     * Webauthn are the settings for server-side Web Authentication support.
     */
    webauthn?: outputs.GetAuthPreferenceSpecWebauthn;
}

export interface GetAuthPreferenceSpecDeviceTrust {
    /**
     * Enable device auto-enroll. Auto-enroll lets any user issue a device enrollment token for a known device that is not already enrolled. `tsh` takes advantage of auto-enroll to automatically enroll devices on user login, when appropriate. The effective cluster Mode still applies: AutoEnroll=true is meaningless if Mode="off".
     */
    autoEnroll?: boolean;
    /**
     * Allow list of EKCert CAs in PEM format. If present, only TPM devices that present an EKCert that is signed by a CA specified here may be enrolled (existing enrollments are unchanged).  If not present, then the CA of TPM EKCerts will not be checked during enrollment, this allows any device to enroll.
     */
    ekcertAllowedCas?: string[];
    /**
     * Mode of verification for trusted devices.  The following modes are supported:  - "off": disables both device authentication and authorization. - "optional": allows both device authentication and authorization, but doesn't enforce the presence of device extensions for sensitive endpoints. - "required": enforces the presence of device extensions for sensitive endpoints.  Mode is always "off" for OSS. Defaults to "optional" for Enterprise.
     */
    mode?: string;
}

export interface GetAuthPreferenceSpecHardwareKey {
    /**
     * PinCacheTTL is the amount of time in nanoseconds that Teleport clients will cache the user's PIV PIN when hardware key PIN policy is enabled.
     */
    pinCacheTtl?: string;
    /**
     * PIVSlot is a PIV slot that Teleport clients should use instead of the default based on private key policy. For example, "9a" or "9e".
     */
    pivSlot?: string;
    /**
     * SerialNumberValidation holds settings for hardware key serial number validation. By default, serial number validation is disabled.
     */
    serialNumberValidation?: outputs.GetAuthPreferenceSpecHardwareKeySerialNumberValidation;
}

export interface GetAuthPreferenceSpecHardwareKeySerialNumberValidation {
    /**
     * Enabled indicates whether hardware key serial number validation is enabled.
     */
    enabled?: boolean;
    /**
     * SerialNumberTraitName is an optional custom user trait name for hardware key serial numbers to replace the default: "hardware_key_serial_numbers".  Note: Values for this user trait should be a comma-separated list of serial numbers, or a list of comm-separated lists. e.g ["123", "345,678"]
     */
    serialNumberTraitName?: string;
}

export interface GetAuthPreferenceSpecIdp {
    /**
     * SAML are options related to the Teleport SAML IdP.
     */
    saml?: outputs.GetAuthPreferenceSpecIdpSaml;
}

export interface GetAuthPreferenceSpecIdpSaml {
    /**
     * Enabled is set to true if this option allows access to the Teleport SAML IdP.
     */
    enabled?: boolean;
}

export interface GetAuthPreferenceSpecOkta {
    /**
     * SyncPeriod is the duration between synchronization calls in nanoseconds.
     */
    syncPeriod?: string;
}

export interface GetAuthPreferenceSpecStableUnixUserConfig {
    /**
     * Enabled signifies that (UNIX) Teleport SSH hosts should obtain a UID from the control plane if they're about to provision a host user with no other configured UID.
     */
    enabled?: boolean;
    /**
     * FirstUid is the start of the range of UIDs for autoprovisioned host users. The range is inclusive on both ends, so the specified UID can be assigned.
     */
    firstUid?: number;
    /**
     * LastUid is the end of the range of UIDs for autoprovisioned host users. The range is inclusive on both ends, so the specified UID can be assigned.
     */
    lastUid?: number;
}

export interface GetAuthPreferenceSpecU2f {
    /**
     * AppID returns the application ID for universal mult-factor.
     */
    appId?: string;
    /**
     * DeviceAttestationCAs contains the trusted attestation CAs for U2F devices.
     */
    deviceAttestationCas?: string[];
    /**
     * Facets returns the facets for universal mult-factor. Deprecated: Kept for backwards compatibility reasons, but Facets have no effect since Teleport v10, when Webauthn replaced the U2F implementation.
     */
    facets?: string[];
}

export interface GetAuthPreferenceSpecWebauthn {
    /**
     * Allow list of device attestation CAs in PEM format. If present, only devices whose attestation certificates match the certificates specified here may be registered (existing registrations are unchanged). If supplied in conjunction with AttestationDeniedCAs, then both conditions need to be true for registration to be allowed (the device MUST match an allowed CA and MUST NOT match a denied CA). By default all devices are allowed.
     */
    attestationAllowedCas?: string[];
    /**
     * Deny list of device attestation CAs in PEM format. If present, only devices whose attestation certificates don't match the certificates specified here may be registered (existing registrations are unchanged). If supplied in conjunction with AttestationAllowedCAs, then both conditions need to be true for registration to be allowed (the device MUST match an allowed CA and MUST NOT match a denied CA). By default no devices are denied.
     */
    attestationDeniedCas?: string[];
    /**
     * RPID is the ID of the Relying Party. It should be set to the domain name of the Teleport installation.  IMPORTANT: RPID must never change in the lifetime of the cluster, because it's recorded in the registration data on the WebAuthn device. If the RPID changes, all existing WebAuthn key registrations will become invalid and all users who use WebAuthn as the multi-factor will need to re-register.
     */
    rpId?: string;
}

export interface GetAutoupdateConfigMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetAutoupdateConfigSpec {
    agents?: outputs.GetAutoupdateConfigSpecAgents;
    tools?: outputs.GetAutoupdateConfigSpecTools;
}

export interface GetAutoupdateConfigSpecAgents {
    /**
     * maintenance_window_duration is the maintenance window duration. This can only be set if `strategy` is "time-based". Once the window is over, the group transitions to the done state. Existing agents won't be updated until the next maintenance window.
     */
    maintenanceWindowDuration?: string;
    /**
     * mode specifies whether agent autoupdates are enabled, disabled, or paused.
     */
    mode?: string;
    /**
     * schedules specifies schedules for updates of grouped agents.
     */
    schedules?: outputs.GetAutoupdateConfigSpecAgentsSchedules;
    /**
     * strategy to use for updating the agents.
     */
    strategy?: string;
}

export interface GetAutoupdateConfigSpecAgentsSchedules {
    /**
     * regular schedules for non-critical versions.
     */
    regulars?: outputs.GetAutoupdateConfigSpecAgentsSchedulesRegular[];
}

export interface GetAutoupdateConfigSpecAgentsSchedulesRegular {
    /**
     * days when the update can run. Supported values are "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" and "*"
     */
    days?: string[];
    /**
     * name of the group
     */
    name?: string;
    /**
     * start_hour to initiate update
     */
    startHour?: number;
    /**
     * wait_hours after last group succeeds before this group can run. This can only be used when the strategy is "halt-on-failure". This field must be positive.
     */
    waitHours?: number;
}

export interface GetAutoupdateConfigSpecTools {
    /**
     * Mode defines state of the client tools auto update.
     */
    mode?: string;
}

export interface GetAutoupdateVersionMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetAutoupdateVersionSpec {
    agents?: outputs.GetAutoupdateVersionSpecAgents;
    tools?: outputs.GetAutoupdateVersionSpecTools;
}

export interface GetAutoupdateVersionSpecAgents {
    /**
     * autoupdate_mode to use for the rollout
     */
    mode?: string;
    /**
     * schedule to use for the rollout
     */
    schedule?: string;
    /**
     * start_version is the version to update from.
     */
    startVersion?: string;
    /**
     * target_version is the version to update to.
     */
    targetVersion?: string;
}

export interface GetAutoupdateVersionSpecTools {
    /**
     * TargetVersion specifies the semantic version required for tools to establish a connection with the cluster. Client tools after connection to the cluster going to be updated to this version automatically.
     */
    targetVersion?: string;
}

export interface GetClusterMaintenanceConfigMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetClusterMaintenanceConfigSpec {
    /**
     * AgentUpgrades encodes the agent upgrade window.
     */
    agentUpgrades?: outputs.GetClusterMaintenanceConfigSpecAgentUpgrades;
}

export interface GetClusterMaintenanceConfigSpecAgentUpgrades {
    /**
     * UTCStartHour is the start hour of the maintenance window in UTC.
     */
    utcStartHour?: number;
    /**
     * Weekdays is an optional list of weekdays. If not specified, an agent upgrade window occurs every day.
     */
    weekdays?: string[];
}

export interface GetClusterNetworkingConfigMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetClusterNetworkingConfigSpec {
    /**
     * AssistCommandExecutionWorkers determines the number of workers that will execute arbitrary Assist commands on servers in parallel
     */
    assistCommandExecutionWorkers?: number;
    /**
     * CaseInsensitiveRouting causes proxies to use case-insensitive hostname matching.
     */
    caseInsensitiveRouting?: boolean;
    /**
     * ClientIdleTimeout sets global cluster default setting for client idle timeouts.
     */
    clientIdleTimeout?: string;
    /**
     * ClientIdleTimeoutMessage is the message sent to the user when a connection times out.
     */
    idleTimeoutMessage?: string;
    /**
     * KeepAliveCountMax is the number of keep-alive messages that can be missed before the server disconnects the connection to the client.
     */
    keepAliveCountMax: number;
    /**
     * KeepAliveInterval is the interval at which the server sends keep-alive messages to the client.
     */
    keepAliveInterval: string;
    /**
     * ProxyListenerMode is proxy listener mode used by Teleport Proxies. 0 is "separate"; 1 is "multiplex".
     */
    proxyListenerMode?: number;
    /**
     * ProxyPingInterval defines in which interval the TLS routing ping message should be sent. This is applicable only when using ping-wrapped connections, regular TLS routing connections are not affected.
     */
    proxyPingInterval?: string;
    /**
     * RoutingStrategy determines the strategy used to route to nodes. 0 is "unambiguous_match"; 1 is "most_recent".
     */
    routingStrategy?: number;
    /**
     * SessionControlTimeout is the session control lease expiry and defines the upper limit of how long a node may be out of contact with the auth server before it begins terminating controlled sessions.
     */
    sessionControlTimeout?: string;
    /**
     * SSHDialTimeout is a custom dial timeout used when establishing SSH connections. If not set, the default timeout of 30s will be used.
     */
    sshDialTimeout?: string;
    /**
     * TunnelStrategyV1 determines the tunnel strategy used in the cluster.
     */
    tunnelStrategy?: outputs.GetClusterNetworkingConfigSpecTunnelStrategy;
    /**
     * WebIdleTimeout sets global cluster default setting for the web UI idle timeouts.
     */
    webIdleTimeout?: string;
}

export interface GetClusterNetworkingConfigSpecTunnelStrategy {
    agentMesh?: outputs.GetClusterNetworkingConfigSpecTunnelStrategyAgentMesh;
    proxyPeering?: outputs.GetClusterNetworkingConfigSpecTunnelStrategyProxyPeering;
}

export interface GetClusterNetworkingConfigSpecTunnelStrategyAgentMesh {
    /**
     * Automatically generated field preventing empty message errors
     */
    active: boolean;
}

export interface GetClusterNetworkingConfigSpecTunnelStrategyProxyPeering {
    agentConnectionCount?: number;
}

export interface GetDatabaseMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetDatabaseSpec {
    /**
     * AD is the Active Directory configuration for the database.
     */
    ad?: outputs.GetDatabaseSpecAd;
    /**
     * AdminUser is the database admin user for automatic user provisioning.
     */
    adminUser?: outputs.GetDatabaseSpecAdminUser;
    /**
     * AWS contains AWS specific settings for RDS/Aurora/Redshift databases.
     */
    aws?: outputs.GetDatabaseSpecAws;
    /**
     * Azure contains Azure specific database metadata.
     */
    azure?: outputs.GetDatabaseSpecAzure;
    /**
     * CACert is the PEM-encoded database CA certificate.  DEPRECATED: Moved to TLS.CACert. DELETE IN 10.0.
     */
    caCert?: string;
    /**
     * DynamicLabels is the database dynamic labels.
     */
    dynamicLabels?: {[key: string]: outputs.GetDatabaseSpecDynamicLabels};
    /**
     * GCP contains parameters specific to GCP Cloud SQL databases.
     */
    gcp?: outputs.GetDatabaseSpecGcp;
    /**
     * MongoAtlas contains Atlas metadata about the database.
     */
    mongoAtlas?: outputs.GetDatabaseSpecMongoAtlas;
    /**
     * MySQL is an additional section with MySQL database options.
     */
    mysql?: outputs.GetDatabaseSpecMysql;
    /**
     * Oracle is an additional Oracle configuration options.
     */
    oracle?: outputs.GetDatabaseSpecOracle;
    /**
     * Protocol is the database protocol: postgres, mysql, mongodb, etc.
     */
    protocol: string;
    /**
     * TLS is the TLS configuration used when establishing connection to target database. Allows to provide custom CA cert or override server name.
     */
    tls?: outputs.GetDatabaseSpecTls;
    /**
     * URI is the database connection endpoint.
     */
    uri: string;
}

export interface GetDatabaseSpecAd {
    /**
     * Domain is the Active Directory domain the database resides in.
     */
    domain?: string;
    /**
     * KDCHostName is the host name for a KDC for x509 Authentication.
     */
    kdcHostName?: string;
    /**
     * KeytabFile is the path to the Kerberos keytab file.
     */
    keytabFile?: string;
    /**
     * Krb5File is the path to the Kerberos configuration file. Defaults to /etc/krb5.conf.
     */
    krb5File?: string;
    /**
     * LDAPCert is a certificate from Windows LDAP/AD, optional; only for x509 Authentication.
     */
    ldapCert?: string;
    /**
     * SPN is the service principal name for the database.
     */
    spn?: string;
}

export interface GetDatabaseSpecAdminUser {
    /**
     * DefaultDatabase is the database that the privileged database user logs into by default.  Depending on the database type, this database may be used to store procedures or data for managing database users.
     */
    defaultDatabase?: string;
    /**
     * Name is the username of the privileged database user.
     */
    name?: string;
}

export interface GetDatabaseSpecAws {
    /**
     * AccountID is the AWS account ID this database belongs to.
     */
    accountId?: string;
    /**
     * AssumeRoleARN is an optional AWS role ARN to assume when accessing a database. Set this field and ExternalID to enable access across AWS accounts.
     */
    assumeRoleArn?: string;
    /**
     * DocumentDB contains AWS DocumentDB specific metadata.
     */
    docdb?: outputs.GetDatabaseSpecAwsDocdb;
    /**
     * ElastiCache contains AWS ElastiCache Redis specific metadata.
     */
    elasticache?: outputs.GetDatabaseSpecAwsElasticache;
    /**
     * ExternalID is an optional AWS external ID used to enable assuming an AWS role across accounts.
     */
    externalId?: string;
    /**
     * IAMPolicyStatus indicates whether the IAM Policy is configured properly for database access. If not, the user must update the AWS profile identity to allow access to the Database. Eg for an RDS Database: the underlying AWS profile allows for `rds-db:connect` for the Database.
     */
    iamPolicyStatus?: number;
    /**
     * MemoryDB contains AWS MemoryDB specific metadata.
     */
    memorydb?: outputs.GetDatabaseSpecAwsMemorydb;
    /**
     * OpenSearch contains AWS OpenSearch specific metadata.
     */
    opensearch?: outputs.GetDatabaseSpecAwsOpensearch;
    /**
     * RDS contains RDS specific metadata.
     */
    rds?: outputs.GetDatabaseSpecAwsRds;
    /**
     * RDSProxy contains AWS Proxy specific metadata.
     */
    rdsproxy?: outputs.GetDatabaseSpecAwsRdsproxy;
    /**
     * Redshift contains Redshift specific metadata.
     */
    redshift?: outputs.GetDatabaseSpecAwsRedshift;
    /**
     * RedshiftServerless contains AWS Redshift Serverless specific metadata.
     */
    redshiftServerless?: outputs.GetDatabaseSpecAwsRedshiftServerless;
    /**
     * Region is a AWS cloud region.
     */
    region?: string;
    /**
     * SecretStore contains secret store configurations.
     */
    secretStore?: outputs.GetDatabaseSpecAwsSecretStore;
    /**
     * SessionTags is a list of AWS STS session tags.
     */
    sessionTags?: {[key: string]: string};
}

export interface GetDatabaseSpecAwsDocdb {
    /**
     * ClusterID is the cluster identifier.
     */
    clusterId?: string;
    /**
     * EndpointType is the type of the endpoint.
     */
    endpointType?: string;
    /**
     * InstanceID is the instance identifier.
     */
    instanceId?: string;
}

export interface GetDatabaseSpecAwsElasticache {
    /**
     * EndpointType is the type of the endpoint.
     */
    endpointType?: string;
    /**
     * ReplicationGroupID is the Redis replication group ID.
     */
    replicationGroupId?: string;
    /**
     * TransitEncryptionEnabled indicates whether in-transit encryption (TLS) is enabled.
     */
    transitEncryptionEnabled?: boolean;
    /**
     * UserGroupIDs is a list of user group IDs.
     */
    userGroupIds?: string[];
}

export interface GetDatabaseSpecAwsMemorydb {
    /**
     * ACLName is the name of the ACL associated with the cluster.
     */
    aclName?: string;
    /**
     * ClusterName is the name of the MemoryDB cluster.
     */
    clusterName?: string;
    /**
     * EndpointType is the type of the endpoint.
     */
    endpointType?: string;
    /**
     * TLSEnabled indicates whether in-transit encryption (TLS) is enabled.
     */
    tlsEnabled?: boolean;
}

export interface GetDatabaseSpecAwsOpensearch {
    /**
     * DomainID is the ID of the domain.
     */
    domainId?: string;
    /**
     * DomainName is the name of the domain.
     */
    domainName?: string;
    /**
     * EndpointType is the type of the endpoint.
     */
    endpointType?: string;
}

export interface GetDatabaseSpecAwsRds {
    /**
     * ClusterID is the RDS cluster (Aurora) identifier.
     */
    clusterId?: string;
    /**
     * IAMAuth indicates whether database IAM authentication is enabled.
     */
    iamAuth?: boolean;
    /**
     * InstanceID is the RDS instance identifier.
     */
    instanceId?: string;
    /**
     * ResourceID is the RDS instance resource identifier (db-xxx).
     */
    resourceId?: string;
    /**
     * SecurityGroups is a list of attached security groups for the RDS instance.
     */
    securityGroups?: string[];
    /**
     * Subnets is a list of subnets for the RDS instance.
     */
    subnets?: string[];
    /**
     * VPCID is the VPC where the RDS is running.
     */
    vpcId?: string;
}

export interface GetDatabaseSpecAwsRdsproxy {
    /**
     * CustomEndpointName is the identifier of an RDS Proxy custom endpoint.
     */
    customEndpointName?: string;
    /**
     * Name is the identifier of an RDS Proxy.
     */
    name?: string;
    /**
     * ResourceID is the RDS instance resource identifier (prx-xxx).
     */
    resourceId?: string;
}

export interface GetDatabaseSpecAwsRedshift {
    /**
     * ClusterID is the Redshift cluster identifier.
     */
    clusterId?: string;
}

export interface GetDatabaseSpecAwsRedshiftServerless {
    /**
     * EndpointName is the VPC endpoint name.
     */
    endpointName?: string;
    /**
     * WorkgroupID is the workgroup ID.
     */
    workgroupId?: string;
    /**
     * WorkgroupName is the workgroup name.
     */
    workgroupName?: string;
}

export interface GetDatabaseSpecAwsSecretStore {
    /**
     * KeyPrefix specifies the secret key prefix.
     */
    keyPrefix?: string;
    /**
     * KMSKeyID specifies the AWS KMS key for encryption.
     */
    kmsKeyId?: string;
}

export interface GetDatabaseSpecAzure {
    /**
     * IsFlexiServer is true if the database is an Azure Flexible server.
     */
    isFlexiServer?: boolean;
    /**
     * Name is the Azure database server name.
     */
    name?: string;
    /**
     * Redis contains Azure Cache for Redis specific database metadata.
     */
    redis?: outputs.GetDatabaseSpecAzureRedis;
    /**
     * ResourceID is the Azure fully qualified ID for the resource.
     */
    resourceId?: string;
}

export interface GetDatabaseSpecAzureRedis {
    /**
     * ClusteringPolicy is the clustering policy for Redis Enterprise.
     */
    clusteringPolicy?: string;
}

export interface GetDatabaseSpecDynamicLabels {
    /**
     * Command is a command to run
     */
    commands?: string[];
    /**
     * Period is a time between command runs
     */
    period?: string;
    /**
     * Result captures standard output
     */
    result?: string;
}

export interface GetDatabaseSpecGcp {
    /**
     * InstanceID is the Cloud SQL instance ID.
     */
    instanceId?: string;
    /**
     * ProjectID is the GCP project ID the Cloud SQL instance resides in.
     */
    projectId?: string;
}

export interface GetDatabaseSpecMongoAtlas {
    /**
     * Name is the Atlas database instance name.
     */
    name?: string;
}

export interface GetDatabaseSpecMysql {
    /**
     * ServerVersion is the server version reported by DB proxy if the runtime information is not available.
     */
    serverVersion?: string;
}

export interface GetDatabaseSpecOracle {
    /**
     * AuditUser is the Oracle database user privilege to access internal Oracle audit trail.
     */
    auditUser?: string;
}

export interface GetDatabaseSpecTls {
    /**
     * CACert is an optional user provided CA certificate used for verifying database TLS connection.
     */
    caCert?: string;
    /**
     * Mode is a TLS connection mode. 0 is "verify-full"; 1 is "verify-ca", 2 is "insecure".
     */
    mode?: number;
    /**
     * ServerName allows to provide custom hostname. This value will override the servername/hostname on a certificate during validation.
     */
    serverName?: string;
    /**
     * TrustSystemCertPool allows Teleport to trust certificate authorities available on the host system. If not set (by default), Teleport only trusts self-signed databases with TLS certificates signed by Teleport's Database Server CA or the ca_cert specified in this TLS setting. For cloud-hosted databases, Teleport downloads the corresponding required CAs for validation.
     */
    trustSystemCertPool?: boolean;
}

export interface GetDynamicWindowsDesktopMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetDynamicWindowsDesktopSpec {
    /**
     * Addr is the address that this host can be reached at.
     */
    addr: string;
    /**
     * Domain is the ActiveDirectory domain that this host belongs to.
     */
    domain?: string;
    /**
     * NonAD marks this desktop as a standalone host that is not joined to an Active Directory domain.
     */
    nonAd?: boolean;
    /**
     * ScreenSize specifies the size of the screen to use for sessions on this host. In most cases this should be unspecified, in which case Teleport will fill the browser window.
     */
    screenSize?: outputs.GetDynamicWindowsDesktopSpecScreenSize;
}

export interface GetDynamicWindowsDesktopSpecScreenSize {
    height?: number;
    width?: number;
}

export interface GetGithubConnectorMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetGithubConnectorSpec {
    /**
     * APIEndpointURL is the URL of the API endpoint of the Github instance this connector is for.
     */
    apiEndpointUrl?: string;
    /**
     * ClientID is the Github OAuth app client ID.
     */
    clientId: string;
    /**
     * ClientRedirectSettings defines which client redirect URLs are allowed for non-browser SSO logins other than the standard localhost ones.
     */
    clientRedirectSettings?: outputs.GetGithubConnectorSpecClientRedirectSettings;
    /**
     * ClientSecret is the Github OAuth app client secret.
     */
    clientSecret: string;
    /**
     * Display is the connector display name.
     */
    display?: string;
    /**
     * EndpointURL is the URL of the GitHub instance this connector is for.
     */
    endpointUrl?: string;
    /**
     * RedirectURL is the authorization callback URL.
     */
    redirectUrl?: string;
    /**
     * TeamsToLogins maps Github team memberships onto allowed logins/roles.  DELETE IN 11.0.0 Deprecated: use GithubTeamsToRoles instead.
     */
    teamsToLogins?: outputs.GetGithubConnectorSpecTeamsToLogin[];
    /**
     * TeamsToRoles maps Github team memberships onto allowed roles.
     */
    teamsToRoles?: outputs.GetGithubConnectorSpecTeamsToRole[];
}

export interface GetGithubConnectorSpecClientRedirectSettings {
    /**
     * a list of hostnames allowed for https client redirect URLs
     */
    allowedHttpsHostnames?: string[];
    /**
     * a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
     */
    insecureAllowedCidrRanges?: string[];
}

export interface GetGithubConnectorSpecTeamsToLogin {
    /**
     * KubeGroups is a list of allowed kubernetes groups for this org/team.
     */
    kubernetesGroups?: string[];
    /**
     * KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
     */
    kubernetesUsers?: string[];
    /**
     * Logins is a list of allowed logins for this org/team.
     */
    logins?: string[];
    /**
     * Organization is a Github organization a user belongs to.
     */
    organization?: string;
    /**
     * Team is a team within the organization a user belongs to.
     */
    team?: string;
}

export interface GetGithubConnectorSpecTeamsToRole {
    /**
     * Organization is a Github organization a user belongs to.
     */
    organization?: string;
    /**
     * Roles is a list of allowed logins for this org/team.
     */
    roles?: string[];
    /**
     * Team is a team within the organization a user belongs to.
     */
    team?: string;
}

export interface GetInstallerMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetInstallerSpec {
    /**
     * Script represents the contents of a installer shell script
     */
    script: string;
}

export interface GetLoginRuleMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetLoginRuleTraitsMap {
    values?: string[];
}

export interface GetOidcConnectorMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetOidcConnectorSpec {
    /**
     * ACR is an Authentication Context Class Reference value. The meaning of the ACR value is context-specific and varies for identity providers.
     */
    acrValues?: string;
    /**
     * AllowUnverifiedEmail tells the connector to accept OIDC users with unverified emails.
     */
    allowUnverifiedEmail?: boolean;
    /**
     * ClaimsToRoles specifies a dynamic mapping from claims to roles.
     */
    claimsToRoles?: outputs.GetOidcConnectorSpecClaimsToRole[];
    /**
     * ClientID is the id of the authentication client (Teleport Auth Service).
     */
    clientId?: string;
    /**
     * ClientRedirectSettings defines which client redirect URLs are allowed for non-browser SSO logins other than the standard localhost ones.
     */
    clientRedirectSettings?: outputs.GetOidcConnectorSpecClientRedirectSettings;
    /**
     * ClientSecret is used to authenticate the client.
     */
    clientSecret?: string;
    /**
     * Display is the friendly name for this provider.
     */
    display?: string;
    /**
     * GoogleAdminEmail is the email of a google admin to impersonate.
     */
    googleAdminEmail?: string;
    /**
     * GoogleServiceAccount is a string containing google service account credentials.
     */
    googleServiceAccount?: string;
    /**
     * GoogleServiceAccountURI is a path to a google service account uri.
     */
    googleServiceAccountUri?: string;
    /**
     * IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
     */
    issuerUrl?: string;
    maxAge?: string;
    /**
     * MFASettings contains settings to enable SSO MFA checks through this auth connector.
     */
    mfa?: outputs.GetOidcConnectorSpecMfa;
    /**
     * Prompt is an optional OIDC prompt. An empty string omits prompt. If not specified, it defaults to select_account for backwards compatibility.
     */
    prompt?: string;
    /**
     * Provider is the external identity provider.
     */
    provider?: string;
    /**
     * RedirectURLs is a list of callback URLs which the identity provider can use to redirect the client back to the Teleport Proxy to complete authentication. This list should match the URLs on the provider's side. The URL used for a given auth request will be chosen to match the requesting Proxy's public address. If there is no match, the first url in the list will be used.
     */
    redirectUrls?: string[];
    /**
     * Scope specifies additional scopes set by provider.
     */
    scopes?: string[];
    /**
     * UsernameClaim specifies the name of the claim from the OIDC connector to be used as the user's username.
     */
    usernameClaim?: string;
}

export interface GetOidcConnectorSpecClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface GetOidcConnectorSpecClientRedirectSettings {
    /**
     * a list of hostnames allowed for https client redirect URLs
     */
    allowedHttpsHostnames?: string[];
    /**
     * a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
     */
    insecureAllowedCidrRanges?: string[];
}

export interface GetOidcConnectorSpecMfa {
    /**
     * AcrValues are Authentication Context Class Reference values. The meaning of the ACR value is context-specific and varies for identity providers. Some identity providers support MFA specific contexts, such Okta with its "phr" (phishing-resistant) ACR.
     */
    acrValues?: string;
    /**
     * ClientID is the OIDC OAuth app client ID.
     */
    clientId?: string;
    /**
     * ClientSecret is the OIDC OAuth app client secret.
     */
    clientSecret?: string;
    /**
     * Enabled specified whether this OIDC connector supports MFA checks. Defaults to false.
     */
    enabled?: boolean;
    /**
     * MaxAge is the amount of time in nanoseconds that an IdP session is valid for. Defaults to 0 to always force re-authentication for MFA checks. This should only be set to a non-zero value if the IdP is setup to perform MFA checks on top of active user sessions.
     */
    maxAge?: string;
    /**
     * Prompt is an optional OIDC prompt. An empty string omits prompt. If not specified, it defaults to select_account for backwards compatibility.
     */
    prompt?: string;
}

export interface GetOktaImportRuleMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetOktaImportRuleSpec {
    /**
     * Mappings is a list of matches that will map match conditions to labels.
     */
    mappings?: outputs.GetOktaImportRuleSpecMapping[];
    /**
     * Priority represents the priority of the rule application. Lower numbered rules will be applied first.
     */
    priority?: number;
}

export interface GetOktaImportRuleSpecMapping {
    /**
     * AddLabels specifies which labels to add if any of the previous matches match.
     */
    addLabels?: {[key: string]: string};
    /**
     * Match is a set of matching rules for this mapping. If any of these match, then the mapping will be applied.
     */
    matches?: outputs.GetOktaImportRuleSpecMappingMatch[];
}

export interface GetOktaImportRuleSpecMappingMatch {
    /**
     * AppIDs is a list of app IDs to match against.
     */
    appIds?: string[];
    /**
     * AppNameRegexes is a list of regexes to match against app names.
     */
    appNameRegexes?: string[];
    /**
     * GroupIDs is a list of group IDs to match against.
     */
    groupIds?: string[];
    /**
     * GroupNameRegexes is a list of regexes to match against group names.
     */
    groupNameRegexes?: string[];
}

export interface GetProvisionTokenMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetProvisionTokenSpec {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecAllow[];
    /**
     * AWSIIDTTL is the TTL to use for AWS EC2 Instance Identity Documents used to join the cluster with this token.
     */
    awsIidTtl: string;
    /**
     * Azure allows the configuration of options specific to the "azure" join method.
     */
    azure?: outputs.GetProvisionTokenSpecAzure;
    /**
     * Bitbucket allows the configuration of options specific to the "bitbucket" join method.
     */
    bitbucket?: outputs.GetProvisionTokenSpecBitbucket;
    /**
     * BotName is the name of the bot this token grants access to, if any
     */
    botName?: string;
    /**
     * CircleCI allows the configuration of options specific to the "circleci" join method.
     */
    circleci?: outputs.GetProvisionTokenSpecCircleci;
    /**
     * GCP allows the configuration of options specific to the "gcp" join method.
     */
    gcp?: outputs.GetProvisionTokenSpecGcp;
    /**
     * GitHub allows the configuration of options specific to the "github" join method.
     */
    github?: outputs.GetProvisionTokenSpecGithub;
    /**
     * GitLab allows the configuration of options specific to the "gitlab" join method.
     */
    gitlab?: outputs.GetProvisionTokenSpecGitlab;
    /**
     * JoinMethod is the joining method required in order to use this token. Supported joining methods include: azure, circleci, ec2, gcp, github, gitlab, iam, kubernetes, spacelift, token, tpm
     */
    joinMethod?: string;
    /**
     * Kubernetes allows the configuration of options specific to the "kubernetes" join method.
     */
    kubernetes?: outputs.GetProvisionTokenSpecKubernetes;
    /**
     * Oracle allows the configuration of options specific to the "oracle" join method.
     */
    oracle?: outputs.GetProvisionTokenSpecOracle;
    /**
     * Roles is a list of roles associated with the token, that will be converted to metadata in the SSH and X509 certificates issued to the user of the token
     */
    roles: string[];
    /**
     * Spacelift allows the configuration of options specific to the "spacelift" join method.
     */
    spacelift?: outputs.GetProvisionTokenSpecSpacelift;
    /**
     * SuggestedAgentMatcherLabels is a set of labels to be used by agents to match on resources. When an agent uses this token, the agent should monitor resources that match those labels. For databases, this means adding the labels to `db_service.resources.labels`. Currently, only node-join scripts create a configuration according to the suggestion.
     */
    suggestedAgentMatcherLabels?: {[key: string]: string[]};
    /**
     * SuggestedLabels is a set of labels that resources should set when using this token to enroll themselves in the cluster. Currently, only node-join scripts create a configuration according to the suggestion.
     */
    suggestedLabels?: {[key: string]: string[]};
    terraformCloud?: outputs.GetProvisionTokenSpecTerraformCloud;
    /**
     * TPM allows the configuration of options specific to the "tpm" join method.
     */
    tpm?: outputs.GetProvisionTokenSpecTpm;
}

export interface GetProvisionTokenSpecAllow {
    /**
     * AWSAccount is the AWS account ID.
     */
    awsAccount?: string;
    /**
     * AWSARN is used for the IAM join method, the AWS identity of joining nodes must match this ARN. Supports wildcards "*" and "?".
     */
    awsArn?: string;
    /**
     * AWSRegions is used for the EC2 join method and is a list of AWS regions a node is allowed to join from.
     */
    awsRegions?: string[];
    /**
     * AWSRole is used for the EC2 join method and is the ARN of the AWS role that the Auth Service will assume in order to call the ec2 API.
     */
    awsRole?: string;
}

export interface GetProvisionTokenSpecAzure {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecAzureAllow[];
}

export interface GetProvisionTokenSpecAzureAllow {
    /**
     * ResourceGroups is a list of Azure resource groups the node is allowed to join from.
     */
    resourceGroups?: string[];
    /**
     * Subscription is the Azure subscription.
     */
    subscription?: string;
}

export interface GetProvisionTokenSpecBitbucket {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecBitbucketAllow[];
    /**
     * Audience is a Bitbucket-specified audience value for this token. It is unique to each Bitbucket repository, and must be set to the value as written in the Pipelines > OpenID Connect section of the repository settings.
     */
    audience?: string;
    /**
     * IdentityProviderURL is a Bitbucket-specified issuer URL for incoming OIDC tokens. It is unique to each Bitbucket repository, and must be set to the value as written in the Pipelines > OpenID Connect section of the repository settings.
     */
    identityProviderUrl?: string;
}

export interface GetProvisionTokenSpecBitbucketAllow {
    /**
     * BranchName is the name of the branch on which this pipeline executed.
     */
    branchName?: string;
    /**
     * DeploymentEnvironmentUUID is the UUID of the deployment environment targeted by this pipelines run, if any. These values may be found in the "Pipelines > OpenID Connect > Deployment environments" section of the repository settings.
     */
    deploymentEnvironmentUuid?: string;
    /**
     * RepositoryUUID is the UUID of the repository for which this token was issued. Bitbucket UUIDs must begin and end with braces, e.g. `{...}`. This value may be found in the Pipelines > OpenID Connect section of the repository settings.
     */
    repositoryUuid?: string;
    /**
     * WorkspaceUUID is the UUID of the workspace for which this token was issued. Bitbucket UUIDs must begin and end with braces, e.g. `{...}`. This value may be found in the Pipelines > OpenID Connect section of the repository settings.
     */
    workspaceUuid?: string;
}

export interface GetProvisionTokenSpecCircleci {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecCircleciAllow[];
    organizationId?: string;
}

export interface GetProvisionTokenSpecCircleciAllow {
    contextId?: string;
    projectId?: string;
}

export interface GetProvisionTokenSpecGcp {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecGcpAllow[];
}

export interface GetProvisionTokenSpecGcpAllow {
    /**
     * Locations is a list of regions (e.g. "us-west1") and/or zones (e.g. "us-west1-b").
     */
    locations?: string[];
    /**
     * ProjectIDs is a list of project IDs (e.g. `<example-id-123456>`).
     */
    projectIds?: string[];
    /**
     * ServiceAccounts is a list of service account emails (e.g. `<project-number>-compute@developer.gserviceaccount.com`).
     */
    serviceAccounts?: string[];
}

export interface GetProvisionTokenSpecGithub {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecGithubAllow[];
    /**
     * EnterpriseServerHost allows joining from runners associated with a GitHub Enterprise Server instance. When unconfigured, tokens will be validated against github.com, but when configured to the host of a GHES instance, then the tokens will be validated against host.  This value should be the hostname of the GHES instance, and should not include the scheme or a path. The instance must be accessible over HTTPS at this hostname and the certificate must be trusted by the Auth Service.
     */
    enterpriseServerHost?: string;
    /**
     * EnterpriseSlug allows the slug of a GitHub Enterprise organisation to be included in the expected issuer of the OIDC tokens. This is for compatibility with the `include_enterprise_slug` option in GHE.  This field should be set to the slug of your enterprise if this is enabled. If this is not enabled, then this field must be left empty. This field cannot be specified if `enterprise_server_host` is specified.  See https://docs.github.com/en/enterprise-cloud@latest/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-issuer-value-for-an-enterprise for more information about customized issuer values.
     */
    enterpriseSlug?: string;
    /**
     * StaticJWKS disables fetching of the GHES signing keys via the JWKS/OIDC endpoints, and allows them to be directly specified. This allows joining from GitHub Actions in GHES instances that are not reachable by the Teleport Auth Service.
     */
    staticJwks?: string;
}

export interface GetProvisionTokenSpecGithubAllow {
    /**
     * The personal account that initiated the workflow run.
     */
    actor?: string;
    /**
     * The name of the environment used by the job.
     */
    environment?: string;
    /**
     * The git ref that triggered the workflow run.
     */
    ref?: string;
    /**
     * The type of ref, for example: "branch".
     */
    refType?: string;
    /**
     * The repository from where the workflow is running. This includes the name of the owner e.g `gravitational/teleport`
     */
    repository?: string;
    /**
     * The name of the organization in which the repository is stored.
     */
    repositoryOwner?: string;
    /**
     * Sub also known as Subject is a string that roughly uniquely identifies the workload. The format of this varies depending on the type of github action run.
     */
    sub?: string;
    /**
     * The name of the workflow.
     */
    workflow?: string;
}

export interface GetProvisionTokenSpecGitlab {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecGitlabAllow[];
    /**
     * Domain is the domain of your GitLab instance. This will default to `gitlab.com` - but can be set to the domain of your self-hosted GitLab e.g `gitlab.example.com`.
     */
    domain?: string;
    /**
     * StaticJWKS disables fetching of the GitLab signing keys via the JWKS/OIDC endpoints, and allows them to be directly specified. This allows joining from GitLab CI instances that are not reachable by the Teleport Auth Service.
     */
    staticJwks?: string;
}

export interface GetProvisionTokenSpecGitlabAllow {
    /**
     * CIConfigRefURI is the ref path to the top-level pipeline definition, for example, gitlab.example.com/my-group/my-project//.gitlab-ci.yml@refs/heads/main.
     */
    ciConfigRefUri?: string;
    /**
     * CIConfigSHA is the git commit SHA for the ci_config_ref_uri.
     */
    ciConfigSha?: string;
    /**
     * DeploymentTier is the deployment tier of the environment the job specifies
     */
    deploymentTier?: string;
    /**
     * Environment limits access by the environment the job deploys to (if one is associated)
     */
    environment?: string;
    /**
     * EnvironmentProtected is true if the Git ref is protected, false otherwise.
     */
    environmentProtected?: boolean;
    /**
     * NamespacePath is used to limit access to jobs in a group or user's projects. Example: `mygroup`  This field supports "glob-style" matching: - Use '*' to match zero or more characters. - Use '?' to match any single character.
     */
    namespacePath?: string;
    /**
     * PipelineSource limits access by the job pipeline source type. https://docs.gitlab.com/ee/ci/jobs/job_control.html#common-if-clauses-for-rules Example: `web`
     */
    pipelineSource?: string;
    /**
     * ProjectPath is used to limit access to jobs belonging to an individual project. Example: `mygroup/myproject`  This field supports "glob-style" matching: - Use '*' to match zero or more characters. - Use '?' to match any single character.
     */
    projectPath?: string;
    /**
     * ProjectVisibility is the visibility of the project where the pipeline is running. Can be internal, private, or public.
     */
    projectVisibility?: string;
    /**
     * Ref allows access to be limited to jobs triggered by a specific git ref. Ensure this is used in combination with ref_type.  This field supports "glob-style" matching: - Use '*' to match zero or more characters. - Use '?' to match any single character.
     */
    ref?: string;
    /**
     * RefProtected is true if the Git ref is protected, false otherwise.
     */
    refProtected?: boolean;
    /**
     * RefType allows access to be limited to jobs triggered by a specific git ref type. Example: `branch` or `tag`
     */
    refType?: string;
    /**
     * Sub roughly uniquely identifies the workload. Example: `project_path:mygroup/my-project:ref_type:branch:ref:main` project_path:GROUP/PROJECT:ref_type:TYPE:ref:BRANCH_NAME  This field supports "glob-style" matching: - Use '*' to match zero or more characters. - Use '?' to match any single character.
     */
    sub?: string;
    /**
     * UserEmail is the email of the user executing the job
     */
    userEmail?: string;
    /**
     * UserID is the ID of the user executing the job
     */
    userId?: string;
    /**
     * UserLogin is the username of the user executing the job
     */
    userLogin?: string;
}

export interface GetProvisionTokenSpecKubernetes {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecKubernetesAllow[];
    /**
     * StaticJWKS is the configuration specific to the `static_jwks` type.
     */
    staticJwks?: outputs.GetProvisionTokenSpecKubernetesStaticJwks;
    /**
     * Type controls which behavior should be used for validating the Kubernetes Service Account token. Support values: - `in_cluster` - `static_jwks` If unset, this defaults to `in_cluster`.
     */
    type?: string;
}

export interface GetProvisionTokenSpecKubernetesAllow {
    /**
     * ServiceAccount is the namespaced name of the Kubernetes service account. Its format is "namespace:service-account".
     */
    serviceAccount?: string;
}

export interface GetProvisionTokenSpecKubernetesStaticJwks {
    /**
     * JWKS should be the JSON Web Key Set formatted public keys of that the Kubernetes Cluster uses to sign service account tokens. This can be fetched from /openid/v1/jwks on the Kubernetes API Server.
     */
    jwks?: string;
}

export interface GetProvisionTokenSpecOracle {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecOracleAllow[];
}

export interface GetProvisionTokenSpecOracleAllow {
    /**
     * ParentCompartments is a list of the OCIDs of compartments an instance is allowed to join from. Only direct parents are allowed, i.e. no nested compartments. If empty, any compartment is allowed.
     */
    parentCompartments?: string[];
    /**
     * Regions is a list of regions an instance is allowed to join from. Both full region names ("us-phoenix-1") and abbreviations ("phx") are allowed. If empty, any region is allowed.
     */
    regions?: string[];
    /**
     * Tenancy is the OCID of the instance's tenancy. Required.
     */
    tenancy?: string;
}

export interface GetProvisionTokenSpecSpacelift {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecSpaceliftAllow[];
    /**
     * Hostname is the hostname of the Spacelift tenant that tokens will originate from. E.g `example.app.spacelift.io`
     */
    hostname?: string;
}

export interface GetProvisionTokenSpecSpaceliftAllow {
    /**
     * CallerID is the ID of the caller, ie. the stack or module that generated the run.
     */
    callerId?: string;
    /**
     * CallerType is the type of the caller, ie. the entity that owns the run - either `stack` or `module`.
     */
    callerType?: string;
    /**
     * Scope is the scope of the token - either `read` or `write`. See https://docs.spacelift.io/integrations/cloud-providers/oidc/#about-scopes
     */
    scope?: string;
    /**
     * SpaceID is the ID of the space in which the run that owns the token was executed.
     */
    spaceId?: string;
}

export interface GetProvisionTokenSpecTerraformCloud {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.GetProvisionTokenSpecTerraformCloudAllow[];
    audience?: string;
    hostname?: string;
}

export interface GetProvisionTokenSpecTerraformCloudAllow {
    organizationId?: string;
    organizationName?: string;
    projectId?: string;
    projectName?: string;
    /**
     * RunPhase is the phase of the run the token was issued for, e.g. `plan` or `apply`
     */
    runPhase?: string;
    workspaceId?: string;
    workspaceName?: string;
}

export interface GetProvisionTokenSpecTpm {
    /**
     * Allow is a list of Rules, the presented delegated identity must match one allow rule to permit joining.
     */
    allows?: outputs.GetProvisionTokenSpecTpmAllow[];
    /**
     * EKCertAllowedCAs is a list of CA certificates that will be used to validate TPM EKCerts. When specified, joining TPMs must present an EKCert signed by one of the specified CAs. TPMs that do not present an EKCert will be not permitted to join. When unspecified, TPMs will be allowed to join with either an EKCert or an EKPubHash.
     */
    ekcertAllowedCas?: string[];
}

export interface GetProvisionTokenSpecTpmAllow {
    /**
     * Description is a human-readable description of the rule. It has no bearing on whether or not a TPM is allowed to join, but can be used to associate a rule with a specific host (e.g the asset tag of the server in which the TPM resides). Example: "build-server-100"
     */
    description?: string;
    /**
     * EKCertificateSerial is the serial number of the EKCert in hexadecimal with colon separated nibbles. This value will not be checked when a TPM does not have an EKCert configured. Example: 73:df:dc:bd:af:ef:8a:d8:15:2e:96:71:7a:3e:7f:a4
     */
    ekCertificateSerial?: string;
    /**
     * EKPublicHash is the SHA256 hash of the EKPub marshaled in PKIX format and encoded in hexadecimal. This value will also be checked when a TPM has submitted an EKCert, and the public key in the EKCert will be used for this check. Example: d4b45864d9d6fabfc568d74f26c35ababde2105337d7af9a6605e1c56c891aa6
     */
    ekPublicHash?: string;
}

export interface GetRoleMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetRoleSpec {
    /**
     * Allow is the set of conditions evaluated to grant access.
     */
    allow?: outputs.GetRoleSpecAllow;
    /**
     * Deny is the set of conditions evaluated to deny access. Deny takes priority over allow.
     */
    deny?: outputs.GetRoleSpecDeny;
    /**
     * Options is for OpenSSH options like agent forwarding.
     */
    options?: outputs.GetRoleSpecOptions;
}

export interface GetRoleSpecAllow {
    /**
     * AccountAssignments holds the list of account assignments affected by this condition.
     */
    accountAssignments?: outputs.GetRoleSpecAllowAccountAssignment[];
    /**
     * AppLabels is a map of labels used as part of the RBAC system.
     */
    appLabels?: {[key: string]: string[]};
    /**
     * AppLabelsExpression is a predicate expression used to allow/deny access to Apps.
     */
    appLabelsExpression?: string;
    /**
     * AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
     */
    awsRoleArns?: string[];
    /**
     * AzureIdentities is a list of Azure identities this role is allowed to assume.
     */
    azureIdentities?: string[];
    /**
     * ClusterLabels is a map of node labels (used to dynamically grant access to clusters).
     */
    clusterLabels?: {[key: string]: string[]};
    /**
     * ClusterLabelsExpression is a predicate expression used to allow/deny access to remote Teleport clusters.
     */
    clusterLabelsExpression?: string;
    /**
     * DatabaseLabels are used in RBAC system to allow/deny access to databases.
     */
    dbLabels?: {[key: string]: string[]};
    /**
     * DatabaseLabelsExpression is a predicate expression used to allow/deny access to Databases.
     */
    dbLabelsExpression?: string;
    /**
     * DatabaseNames is a list of database names this role is allowed to connect to.
     */
    dbNames?: string[];
    /**
     * DatabasePermissions specifies a set of permissions that will be granted to the database user when using automatic database user provisioning.
     */
    dbPermissions?: outputs.GetRoleSpecAllowDbPermission[];
    /**
     * DatabaseRoles is a list of databases roles for automatic user creation.
     */
    dbRoles?: string[];
    /**
     * DatabaseServiceLabels are used in RBAC system to allow/deny access to Database Services.
     */
    dbServiceLabels?: {[key: string]: string[]};
    /**
     * DatabaseServiceLabelsExpression is a predicate expression used to allow/deny access to Database Services.
     */
    dbServiceLabelsExpression?: string;
    /**
     * DatabaseUsers is a list of databases users this role is allowed to connect as.
     */
    dbUsers?: string[];
    /**
     * DesktopGroups is a list of groups for created desktop users to be added to
     */
    desktopGroups?: string[];
    /**
     * GCPServiceAccounts is a list of GCP service accounts this role is allowed to assume.
     */
    gcpServiceAccounts?: string[];
    /**
     * GitHubPermissions defines GitHub integration related permissions.
     */
    githubPermissions?: outputs.GetRoleSpecAllowGithubPermission[];
    /**
     * GroupLabels is a map of labels used as part of the RBAC system.
     */
    groupLabels?: {[key: string]: string[]};
    /**
     * GroupLabelsExpression is a predicate expression used to allow/deny access to user groups.
     */
    groupLabelsExpression?: string;
    /**
     * HostGroups is a list of groups for created users to be added to
     */
    hostGroups?: string[];
    /**
     * HostSudoers is a list of entries to include in a users sudoer file
     */
    hostSudoers?: string[];
    /**
     * Impersonate specifies what users and roles this role is allowed to impersonate by issuing certificates or other possible means.
     */
    impersonate?: outputs.GetRoleSpecAllowImpersonate;
    /**
     * JoinSessions specifies policies to allow users to join other sessions.
     */
    joinSessions?: outputs.GetRoleSpecAllowJoinSession[];
    /**
     * KubeGroups is a list of kubernetes groups
     */
    kubernetesGroups?: string[];
    /**
     * KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
     */
    kubernetesLabels?: {[key: string]: string[]};
    /**
     * KubernetesLabelsExpression is a predicate expression used to allow/deny access to kubernetes clusters.
     */
    kubernetesLabelsExpression?: string;
    /**
     * KubernetesResources is the Kubernetes Resources this Role grants access to.
     */
    kubernetesResources: outputs.GetRoleSpecAllowKubernetesResource[];
    /**
     * KubeUsers is an optional kubernetes users to impersonate
     */
    kubernetesUsers?: string[];
    /**
     * Logins is a list of *nix system logins.
     */
    logins?: string[];
    /**
     * NodeLabels is a map of node labels (used to dynamically grant access to nodes).
     */
    nodeLabels?: {[key: string]: string[]};
    /**
     * NodeLabelsExpression is a predicate expression used to allow/deny access to SSH nodes.
     */
    nodeLabelsExpression?: string;
    request?: outputs.GetRoleSpecAllowRequest;
    /**
     * RequireSessionJoin specifies policies for required users to start a session.
     */
    requireSessionJoins?: outputs.GetRoleSpecAllowRequireSessionJoin[];
    /**
     * ReviewRequests defines conditions for submitting access reviews.
     */
    reviewRequests?: outputs.GetRoleSpecAllowReviewRequests;
    /**
     * Rules is a list of rules and their access levels. Rules are a high level construct used for access control.
     */
    rules?: outputs.GetRoleSpecAllowRule[];
    /**
     * SPIFFE is used to allow or deny access to a role holder to generating a SPIFFE SVID.
     */
    spiffes?: outputs.GetRoleSpecAllowSpiffe[];
    /**
     * WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
     */
    windowsDesktopLabels?: {[key: string]: string[]};
    /**
     * WindowsDesktopLabelsExpression is a predicate expression used to allow/deny access to Windows desktops.
     */
    windowsDesktopLabelsExpression?: string;
    /**
     * WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
     */
    windowsDesktopLogins?: string[];
    /**
     * WorkloadIdentityLabels controls whether or not specific WorkloadIdentity resources can be invoked. Further authorization controls exist on the WorkloadIdentity resource itself.
     */
    workloadIdentityLabels?: {[key: string]: string[]};
    /**
     * WorkloadIdentityLabelsExpression is a predicate expression used to allow/deny access to issuing a WorkloadIdentity.
     */
    workloadIdentityLabelsExpression?: string;
}

export interface GetRoleSpecAllowAccountAssignment {
    account?: string;
    permissionSet?: string;
}

export interface GetRoleSpecAllowDbPermission {
    /**
     * Match is a list of object labels that must be matched for the permission to be granted.
     */
    match?: {[key: string]: string[]};
    /**
     * Permission is the list of string representations of the permission to be given, e.g. SELECT, INSERT, UPDATE, ...
     */
    permissions?: string[];
}

export interface GetRoleSpecAllowGithubPermission {
    orgs?: string[];
}

export interface GetRoleSpecAllowImpersonate {
    /**
     * Roles is a list of resources this role is allowed to impersonate
     */
    roles?: string[];
    /**
     * Users is a list of resources this role is allowed to impersonate, could be an empty list or a Wildcard pattern
     */
    users?: string[];
    /**
     * Where specifies optional advanced matcher
     */
    where?: string;
}

export interface GetRoleSpecAllowJoinSession {
    /**
     * Kinds are the session kinds this policy applies to.
     */
    kinds?: string[];
    /**
     * Modes is a list of permitted participant modes for this policy.
     */
    modes?: string[];
    /**
     * Name is the name of the policy.
     */
    name?: string;
    /**
     * Roles is a list of roles that you can join the session of.
     */
    roles?: string[];
}

export interface GetRoleSpecAllowKubernetesResource {
    /**
     * Kind specifies the Kubernetes Resource type.
     */
    kind?: string;
    /**
     * Name is the resource name. It supports wildcards.
     */
    name?: string;
    /**
     * Namespace is the resource namespace. It supports wildcards.
     */
    namespace?: string;
    /**
     * Verbs are the allowed Kubernetes verbs for the following resource.
     */
    verbs: string[];
}

export interface GetRoleSpecAllowRequest {
    /**
     * Annotations is a collection of annotations to be programmatically appended to pending Access Requests at the time of their creation. These annotations serve as a mechanism to propagate extra information to plugins.  Since these annotations support variable interpolation syntax, they also offer a mechanism for forwarding claims from an external identity provider, to a plugin via `{{external.trait_name}}` style substitutions.
     */
    annotations?: {[key: string]: string[]};
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     */
    claimsToRoles?: outputs.GetRoleSpecAllowRequestClaimsToRole[];
    /**
     * kubernetes_resources can optionally enforce a requester to request only certain kinds of kube resources. Eg: Users can make request to either a resource kind "kube_cluster" or any of its subresources like "namespaces". This field can be defined such that it prevents a user from requesting "kube_cluster" and enforce requesting any of its subresources.
     */
    kubernetesResources?: outputs.GetRoleSpecAllowRequestKubernetesResource[];
    /**
     * MaxDuration is the amount of time the access will be granted for. If this is zero, the default duration is used.
     */
    maxDuration?: string;
    /**
     * Reason defines settings for the reason for the access provided by the user.
     */
    reason?: outputs.GetRoleSpecAllowRequestReason;
    /**
     * Roles is the name of roles which will match the request rule.
     */
    roles?: string[];
    /**
     * SearchAsRoles is a list of extra roles which should apply to a user while they are searching for resources as part of a Resource Access Request, and defines the underlying roles which will be requested as part of any Resource Access Request.
     */
    searchAsRoles?: string[];
    /**
     * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but that is not a requirement.
     */
    suggestedReviewers?: string[];
    /**
     * Thresholds is a list of thresholds, one of which must be met in order for reviews to trigger a state-transition.  If no thresholds are provided, a default threshold of 1 for approval and denial is used.
     */
    thresholds?: outputs.GetRoleSpecAllowRequestThreshold[];
}

export interface GetRoleSpecAllowRequestClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface GetRoleSpecAllowRequestKubernetesResource {
    /**
     * kind specifies the Kubernetes Resource type.
     */
    kind?: string;
}

export interface GetRoleSpecAllowRequestReason {
    /**
     * Mode can be either "required" or "optional". Empty string is treated as "optional". If a role has the request reason mode set to "required", then reason is required for all Access Requests requesting roles or resources allowed by this role. It applies only to users who have this role assigned.
     */
    mode?: string;
}

export interface GetRoleSpecAllowRequestThreshold {
    /**
     * Approve is the number of matching approvals needed for state-transition.
     */
    approve?: number;
    /**
     * Deny is the number of denials needed for state-transition.
     */
    deny?: number;
    /**
     * Filter is an optional predicate used to determine which reviews count toward this threshold.
     */
    filter?: string;
    /**
     * Name is the optional human-readable name of the threshold.
     */
    name?: string;
}

export interface GetRoleSpecAllowRequireSessionJoin {
    /**
     * Count is the amount of people that need to be matched for this policy to be fulfilled.
     */
    count?: number;
    /**
     * Filter is a predicate that determines what users count towards this policy.
     */
    filter?: string;
    /**
     * Kinds are the session kinds this policy applies to.
     */
    kinds?: string[];
    /**
     * Modes is the list of modes that may be used to fulfill this policy.
     */
    modes?: string[];
    /**
     * Name is the name of the policy.
     */
    name?: string;
    /**
     * OnLeave is the behaviour that's used when the policy is no longer fulfilled for a live session.
     */
    onLeave?: string;
}

export interface GetRoleSpecAllowReviewRequests {
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     */
    claimsToRoles?: outputs.GetRoleSpecAllowReviewRequestsClaimsToRole[];
    /**
     * PreviewAsRoles is a list of extra roles which should apply to a reviewer while they are viewing a Resource Access Request for the purposes of viewing details such as the hostname and labels of requested resources.
     */
    previewAsRoles?: string[];
    /**
     * Roles is the name of roles which may be reviewed.
     */
    roles?: string[];
    /**
     * Where is an optional predicate which further limits which requests are reviewable.
     */
    where?: string;
}

export interface GetRoleSpecAllowReviewRequestsClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface GetRoleSpecAllowRule {
    /**
     * Actions specifies optional actions taken when this rule matches
     */
    actions?: string[];
    /**
     * Resources is a list of resources
     */
    resources?: string[];
    /**
     * Verbs is a list of verbs
     */
    verbs?: string[];
    /**
     * Where specifies optional advanced matcher
     */
    where?: string;
}

export interface GetRoleSpecAllowSpiffe {
    /**
     * DNSSANs specifies matchers for the SPIFFE ID DNS SANs.  Each requested DNS SAN is compared against all matchers configured and if any match, the condition is considered to be met.  The matcher by default allows '*' to be used to indicate zero or more of any character. Prepend '^' and append '$' to instead switch to matching using the Go regex syntax.  Example: *.example.com would match foo.example.com
     */
    dnsSans?: string[];
    /**
     * IPSANs specifies matchers for the SPIFFE ID IP SANs.  Each requested IP SAN is compared against all matchers configured and if any match, the condition is considered to be met.  The matchers should be specified using CIDR notation, it supports IPv4 and IPv6.  Examples: - 10.0.0.0/24 would match 10.0.0.0 to 10.255.255.255 - 10.0.0.42/32 would match only 10.0.0.42
     */
    ipSans?: string[];
    /**
     * Path specifies a matcher for the SPIFFE ID path. It should not include the trust domain and should start with a leading slash.  The matcher by default allows '*' to be used to indicate zero or more of any character. Prepend '^' and append '$' to instead switch to matching using the Go regex syntax.  Example: - /svc/foo/*&#47;bar would match /svc/foo/baz/bar - ^\/svc\/foo\/.*\/bar$ would match /svc/foo/baz/bar
     */
    path?: string;
}

export interface GetRoleSpecDeny {
    /**
     * AccountAssignments holds the list of account assignments affected by this condition.
     */
    accountAssignments?: outputs.GetRoleSpecDenyAccountAssignment[];
    /**
     * AppLabels is a map of labels used as part of the RBAC system.
     */
    appLabels?: {[key: string]: string[]};
    /**
     * AppLabelsExpression is a predicate expression used to allow/deny access to Apps.
     */
    appLabelsExpression?: string;
    /**
     * AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
     */
    awsRoleArns?: string[];
    /**
     * AzureIdentities is a list of Azure identities this role is allowed to assume.
     */
    azureIdentities?: string[];
    /**
     * ClusterLabels is a map of node labels (used to dynamically grant access to clusters).
     */
    clusterLabels?: {[key: string]: string[]};
    /**
     * ClusterLabelsExpression is a predicate expression used to allow/deny access to remote Teleport clusters.
     */
    clusterLabelsExpression?: string;
    /**
     * DatabaseLabels are used in RBAC system to allow/deny access to databases.
     */
    dbLabels?: {[key: string]: string[]};
    /**
     * DatabaseLabelsExpression is a predicate expression used to allow/deny access to Databases.
     */
    dbLabelsExpression?: string;
    /**
     * DatabaseNames is a list of database names this role is allowed to connect to.
     */
    dbNames?: string[];
    /**
     * DatabasePermissions specifies a set of permissions that will be granted to the database user when using automatic database user provisioning.
     */
    dbPermissions?: outputs.GetRoleSpecDenyDbPermission[];
    /**
     * DatabaseRoles is a list of databases roles for automatic user creation.
     */
    dbRoles?: string[];
    /**
     * DatabaseServiceLabels are used in RBAC system to allow/deny access to Database Services.
     */
    dbServiceLabels?: {[key: string]: string[]};
    /**
     * DatabaseServiceLabelsExpression is a predicate expression used to allow/deny access to Database Services.
     */
    dbServiceLabelsExpression?: string;
    /**
     * DatabaseUsers is a list of databases users this role is allowed to connect as.
     */
    dbUsers?: string[];
    /**
     * DesktopGroups is a list of groups for created desktop users to be added to
     */
    desktopGroups?: string[];
    /**
     * GCPServiceAccounts is a list of GCP service accounts this role is allowed to assume.
     */
    gcpServiceAccounts?: string[];
    /**
     * GitHubPermissions defines GitHub integration related permissions.
     */
    githubPermissions?: outputs.GetRoleSpecDenyGithubPermission[];
    /**
     * GroupLabels is a map of labels used as part of the RBAC system.
     */
    groupLabels?: {[key: string]: string[]};
    /**
     * GroupLabelsExpression is a predicate expression used to allow/deny access to user groups.
     */
    groupLabelsExpression?: string;
    /**
     * HostGroups is a list of groups for created users to be added to
     */
    hostGroups?: string[];
    /**
     * HostSudoers is a list of entries to include in a users sudoer file
     */
    hostSudoers?: string[];
    /**
     * Impersonate specifies what users and roles this role is allowed to impersonate by issuing certificates or other possible means.
     */
    impersonate?: outputs.GetRoleSpecDenyImpersonate;
    /**
     * JoinSessions specifies policies to allow users to join other sessions.
     */
    joinSessions?: outputs.GetRoleSpecDenyJoinSession[];
    /**
     * KubeGroups is a list of kubernetes groups
     */
    kubernetesGroups?: string[];
    /**
     * KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
     */
    kubernetesLabels?: {[key: string]: string[]};
    /**
     * KubernetesLabelsExpression is a predicate expression used to allow/deny access to kubernetes clusters.
     */
    kubernetesLabelsExpression?: string;
    /**
     * KubernetesResources is the Kubernetes Resources this Role grants access to.
     */
    kubernetesResources?: outputs.GetRoleSpecDenyKubernetesResource[];
    /**
     * KubeUsers is an optional kubernetes users to impersonate
     */
    kubernetesUsers?: string[];
    /**
     * Logins is a list of *nix system logins.
     */
    logins?: string[];
    /**
     * NodeLabels is a map of node labels (used to dynamically grant access to nodes).
     */
    nodeLabels?: {[key: string]: string[]};
    /**
     * NodeLabelsExpression is a predicate expression used to allow/deny access to SSH nodes.
     */
    nodeLabelsExpression?: string;
    request?: outputs.GetRoleSpecDenyRequest;
    /**
     * RequireSessionJoin specifies policies for required users to start a session.
     */
    requireSessionJoins?: outputs.GetRoleSpecDenyRequireSessionJoin[];
    /**
     * ReviewRequests defines conditions for submitting access reviews.
     */
    reviewRequests?: outputs.GetRoleSpecDenyReviewRequests;
    /**
     * Rules is a list of rules and their access levels. Rules are a high level construct used for access control.
     */
    rules?: outputs.GetRoleSpecDenyRule[];
    /**
     * SPIFFE is used to allow or deny access to a role holder to generating a SPIFFE SVID.
     */
    spiffes?: outputs.GetRoleSpecDenySpiffe[];
    /**
     * WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
     */
    windowsDesktopLabels?: {[key: string]: string[]};
    /**
     * WindowsDesktopLabelsExpression is a predicate expression used to allow/deny access to Windows desktops.
     */
    windowsDesktopLabelsExpression?: string;
    /**
     * WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
     */
    windowsDesktopLogins?: string[];
    /**
     * WorkloadIdentityLabels controls whether or not specific WorkloadIdentity resources can be invoked. Further authorization controls exist on the WorkloadIdentity resource itself.
     */
    workloadIdentityLabels?: {[key: string]: string[]};
    /**
     * WorkloadIdentityLabelsExpression is a predicate expression used to allow/deny access to issuing a WorkloadIdentity.
     */
    workloadIdentityLabelsExpression?: string;
}

export interface GetRoleSpecDenyAccountAssignment {
    account?: string;
    permissionSet?: string;
}

export interface GetRoleSpecDenyDbPermission {
    /**
     * Match is a list of object labels that must be matched for the permission to be granted.
     */
    match?: {[key: string]: string[]};
    /**
     * Permission is the list of string representations of the permission to be given, e.g. SELECT, INSERT, UPDATE, ...
     */
    permissions?: string[];
}

export interface GetRoleSpecDenyGithubPermission {
    orgs?: string[];
}

export interface GetRoleSpecDenyImpersonate {
    /**
     * Roles is a list of resources this role is allowed to impersonate
     */
    roles?: string[];
    /**
     * Users is a list of resources this role is allowed to impersonate, could be an empty list or a Wildcard pattern
     */
    users?: string[];
    /**
     * Where specifies optional advanced matcher
     */
    where?: string;
}

export interface GetRoleSpecDenyJoinSession {
    /**
     * Kinds are the session kinds this policy applies to.
     */
    kinds?: string[];
    /**
     * Modes is a list of permitted participant modes for this policy.
     */
    modes?: string[];
    /**
     * Name is the name of the policy.
     */
    name?: string;
    /**
     * Roles is a list of roles that you can join the session of.
     */
    roles?: string[];
}

export interface GetRoleSpecDenyKubernetesResource {
    /**
     * Kind specifies the Kubernetes Resource type.
     */
    kind?: string;
    /**
     * Name is the resource name. It supports wildcards.
     */
    name?: string;
    /**
     * Namespace is the resource namespace. It supports wildcards.
     */
    namespace?: string;
    /**
     * Verbs are the allowed Kubernetes verbs for the following resource.
     */
    verbs?: string[];
}

export interface GetRoleSpecDenyRequest {
    /**
     * Annotations is a collection of annotations to be programmatically appended to pending Access Requests at the time of their creation. These annotations serve as a mechanism to propagate extra information to plugins.  Since these annotations support variable interpolation syntax, they also offer a mechanism for forwarding claims from an external identity provider, to a plugin via `{{external.trait_name}}` style substitutions.
     */
    annotations?: {[key: string]: string[]};
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     */
    claimsToRoles?: outputs.GetRoleSpecDenyRequestClaimsToRole[];
    /**
     * kubernetes_resources can optionally enforce a requester to request only certain kinds of kube resources. Eg: Users can make request to either a resource kind "kube_cluster" or any of its subresources like "namespaces". This field can be defined such that it prevents a user from requesting "kube_cluster" and enforce requesting any of its subresources.
     */
    kubernetesResources?: outputs.GetRoleSpecDenyRequestKubernetesResource[];
    /**
     * MaxDuration is the amount of time the access will be granted for. If this is zero, the default duration is used.
     */
    maxDuration?: string;
    /**
     * Reason defines settings for the reason for the access provided by the user.
     */
    reason?: outputs.GetRoleSpecDenyRequestReason;
    /**
     * Roles is the name of roles which will match the request rule.
     */
    roles?: string[];
    /**
     * SearchAsRoles is a list of extra roles which should apply to a user while they are searching for resources as part of a Resource Access Request, and defines the underlying roles which will be requested as part of any Resource Access Request.
     */
    searchAsRoles?: string[];
    /**
     * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but that is not a requirement.
     */
    suggestedReviewers?: string[];
    /**
     * Thresholds is a list of thresholds, one of which must be met in order for reviews to trigger a state-transition.  If no thresholds are provided, a default threshold of 1 for approval and denial is used.
     */
    thresholds?: outputs.GetRoleSpecDenyRequestThreshold[];
}

export interface GetRoleSpecDenyRequestClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface GetRoleSpecDenyRequestKubernetesResource {
    /**
     * kind specifies the Kubernetes Resource type.
     */
    kind?: string;
}

export interface GetRoleSpecDenyRequestReason {
    /**
     * Mode can be either "required" or "optional". Empty string is treated as "optional". If a role has the request reason mode set to "required", then reason is required for all Access Requests requesting roles or resources allowed by this role. It applies only to users who have this role assigned.
     */
    mode?: string;
}

export interface GetRoleSpecDenyRequestThreshold {
    /**
     * Approve is the number of matching approvals needed for state-transition.
     */
    approve?: number;
    /**
     * Deny is the number of denials needed for state-transition.
     */
    deny?: number;
    /**
     * Filter is an optional predicate used to determine which reviews count toward this threshold.
     */
    filter?: string;
    /**
     * Name is the optional human-readable name of the threshold.
     */
    name?: string;
}

export interface GetRoleSpecDenyRequireSessionJoin {
    /**
     * Count is the amount of people that need to be matched for this policy to be fulfilled.
     */
    count?: number;
    /**
     * Filter is a predicate that determines what users count towards this policy.
     */
    filter?: string;
    /**
     * Kinds are the session kinds this policy applies to.
     */
    kinds?: string[];
    /**
     * Modes is the list of modes that may be used to fulfill this policy.
     */
    modes?: string[];
    /**
     * Name is the name of the policy.
     */
    name?: string;
    /**
     * OnLeave is the behaviour that's used when the policy is no longer fulfilled for a live session.
     */
    onLeave?: string;
}

export interface GetRoleSpecDenyReviewRequests {
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     */
    claimsToRoles?: outputs.GetRoleSpecDenyReviewRequestsClaimsToRole[];
    /**
     * PreviewAsRoles is a list of extra roles which should apply to a reviewer while they are viewing a Resource Access Request for the purposes of viewing details such as the hostname and labels of requested resources.
     */
    previewAsRoles?: string[];
    /**
     * Roles is the name of roles which may be reviewed.
     */
    roles?: string[];
    /**
     * Where is an optional predicate which further limits which requests are reviewable.
     */
    where?: string;
}

export interface GetRoleSpecDenyReviewRequestsClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface GetRoleSpecDenyRule {
    /**
     * Actions specifies optional actions taken when this rule matches
     */
    actions?: string[];
    /**
     * Resources is a list of resources
     */
    resources?: string[];
    /**
     * Verbs is a list of verbs
     */
    verbs?: string[];
    /**
     * Where specifies optional advanced matcher
     */
    where?: string;
}

export interface GetRoleSpecDenySpiffe {
    /**
     * DNSSANs specifies matchers for the SPIFFE ID DNS SANs.  Each requested DNS SAN is compared against all matchers configured and if any match, the condition is considered to be met.  The matcher by default allows '*' to be used to indicate zero or more of any character. Prepend '^' and append '$' to instead switch to matching using the Go regex syntax.  Example: *.example.com would match foo.example.com
     */
    dnsSans?: string[];
    /**
     * IPSANs specifies matchers for the SPIFFE ID IP SANs.  Each requested IP SAN is compared against all matchers configured and if any match, the condition is considered to be met.  The matchers should be specified using CIDR notation, it supports IPv4 and IPv6.  Examples: - 10.0.0.0/24 would match 10.0.0.0 to 10.255.255.255 - 10.0.0.42/32 would match only 10.0.0.42
     */
    ipSans?: string[];
    /**
     * Path specifies a matcher for the SPIFFE ID path. It should not include the trust domain and should start with a leading slash.  The matcher by default allows '*' to be used to indicate zero or more of any character. Prepend '^' and append '$' to instead switch to matching using the Go regex syntax.  Example: - /svc/foo/*&#47;bar would match /svc/foo/baz/bar - ^\/svc\/foo\/.*\/bar$ would match /svc/foo/baz/bar
     */
    path?: string;
}

export interface GetRoleSpecOptions {
    /**
     * CertExtensions specifies the key/values
     */
    certExtensions?: outputs.GetRoleSpecOptionsCertExtension[];
    /**
     * CertificateFormat defines the format of the user certificate to allow compatibility with older versions of OpenSSH.
     */
    certFormat: string;
    /**
     * ClientIdleTimeout sets disconnect clients on idle timeout behavior, if set to 0 means do not disconnect, otherwise is set to the idle duration.
     */
    clientIdleTimeout?: string;
    /**
     * CreateDatabaseUser enabled automatic database user creation.
     */
    createDbUser?: boolean;
    /**
     * CreateDatabaseUserMode allows users to be automatically created on a database when not set to off. 0 is "unspecified", 1 is "off", 2 is "keep", 3 is "best_effort_drop".
     */
    createDbUserMode?: number;
    /**
     * CreateDesktopUser allows users to be automatically created on a Windows desktop
     */
    createDesktopUser?: boolean;
    /**
     * Deprecated: use CreateHostUserMode instead.
     */
    createHostUser?: boolean;
    /**
     * CreateHostUserDefaultShell is used to configure the default shell for newly provisioned host users.
     */
    createHostUserDefaultShell?: string;
    /**
     * CreateHostUserMode allows users to be automatically created on a host when not set to off. 0 is "unspecified"; 1 is "off"; 2 is "drop" (removed for v15 and above), 3 is "keep"; 4 is "insecure-drop".
     */
    createHostUserMode?: number;
    /**
     * DesktopClipboard indicates whether clipboard sharing is allowed between the user's workstation and the remote desktop. It defaults to true unless explicitly set to false.
     */
    desktopClipboard?: boolean;
    /**
     * DesktopDirectorySharing indicates whether directory sharing is allowed between the user's workstation and the remote desktop. It defaults to false unless explicitly set to true.
     */
    desktopDirectorySharing?: boolean;
    /**
     * DeviceTrustMode is the device authorization mode used for the resources associated with the role. See DeviceTrust.Mode.
     */
    deviceTrustMode?: string;
    /**
     * DisconnectExpiredCert sets disconnect clients on expired certificates.
     */
    disconnectExpiredCert?: boolean;
    /**
     * BPF defines what events to record for the BPF-based session recorder.
     */
    enhancedRecordings: string[];
    /**
     * ForwardAgent is SSH agent forwarding.
     */
    forwardAgent?: boolean;
    /**
     * IDP is a set of options related to accessing IdPs within Teleport. Requires Teleport Enterprise.
     */
    idp?: outputs.GetRoleSpecOptionsIdp;
    /**
     * Lock specifies the locking mode (strict|best_effort) to be applied with the role.
     */
    lock?: string;
    /**
     * MaxConnections defines the maximum number of concurrent connections a user may hold.
     */
    maxConnections?: number;
    /**
     * MaxKubernetesConnections defines the maximum number of concurrent Kubernetes sessions a user may hold.
     */
    maxKubernetesConnections?: number;
    /**
     * MaxSessionTTL defines how long a SSH session can last for.
     */
    maxSessionTtl: string;
    /**
     * MaxSessions defines the maximum number of concurrent sessions per connection.
     */
    maxSessions?: number;
    /**
     * MFAVerificationInterval optionally defines the maximum duration that can elapse between successive MFA verifications. This variable is used to ensure that users are periodically prompted to verify their identity, enhancing security by preventing prolonged sessions without re-authentication when using tsh proxy * derivatives. It's only effective if the session requires MFA. If not set, defaults to `max_session_ttl`.
     */
    mfaVerificationInterval?: string;
    /**
     * PermitX11Forwarding authorizes use of X11 forwarding.
     */
    permitX11Forwarding?: boolean;
    /**
     * PinSourceIP forces the same client IP for certificate generation and usage
     */
    pinSourceIp?: boolean;
    /**
     * Deprecated: Use SSHPortForwarding instead
     */
    portForwarding?: boolean;
    /**
     * RecordDesktopSession indicates whether desktop access sessions should be recorded. It defaults to true unless explicitly set to false.
     */
    recordSession?: outputs.GetRoleSpecOptionsRecordSession;
    /**
     * RequestAccess defines the request strategy (optional|reason|always) where optional is the default.
     */
    requestAccess?: string;
    /**
     * RequestPrompt is an optional message which tells users what they aught to request.
     */
    requestPrompt?: string;
    /**
     * RequireMFAType is the type of MFA requirement enforced for this user. 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH", 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
     */
    requireSessionMfa?: number;
    /**
     * SSHFileCopy indicates whether remote file operations via SCP or SFTP are allowed over an SSH session. It defaults to true unless explicitly set to false.
     */
    sshFileCopy?: boolean;
    /**
     * SSHPortForwarding configures what types of SSH port forwarding are allowed by a role.
     */
    sshPortForwarding?: outputs.GetRoleSpecOptionsSshPortForwarding;
}

export interface GetRoleSpecOptionsCertExtension {
    /**
     * Mode is the type of extension to be used -- currently critical-option is not supported. 0 is "extension".
     */
    mode?: number;
    /**
     * Name specifies the key to be used in the cert extension.
     */
    name?: string;
    /**
     * Type represents the certificate type being extended, only ssh is supported at this time. 0 is "ssh".
     */
    type?: number;
    /**
     * Value specifies the value to be used in the cert extension.
     */
    value?: string;
}

export interface GetRoleSpecOptionsIdp {
    /**
     * SAML are options related to the Teleport SAML IdP.
     */
    saml?: outputs.GetRoleSpecOptionsIdpSaml;
}

export interface GetRoleSpecOptionsIdpSaml {
    /**
     * Enabled is set to true if this option allows access to the Teleport SAML IdP.
     */
    enabled?: boolean;
}

export interface GetRoleSpecOptionsRecordSession {
    /**
     * Default indicates the default value for the services.
     */
    default?: string;
    /**
     * Desktop indicates whether desktop sessions should be recorded. It defaults to true unless explicitly set to false.
     */
    desktop?: boolean;
    /**
     * SSH indicates the session mode used on SSH sessions.
     */
    ssh?: string;
}

export interface GetRoleSpecOptionsSshPortForwarding {
    /**
     * Allow local port forwarding.
     */
    local?: outputs.GetRoleSpecOptionsSshPortForwardingLocal;
    /**
     * Allow remote port forwarding.
     */
    remote?: outputs.GetRoleSpecOptionsSshPortForwardingRemote;
}

export interface GetRoleSpecOptionsSshPortForwardingLocal {
    enabled?: boolean;
}

export interface GetRoleSpecOptionsSshPortForwardingRemote {
    enabled?: boolean;
}

export interface GetSamlConnectorMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetSamlConnectorSpec {
    /**
     * AssertionConsumerService is a URL for assertion consumer service on the service provider (Teleport's side).
     */
    acs: string;
    /**
     * AllowIDPInitiated is a flag that indicates if the connector can be used for IdP-initiated logins.
     */
    allowIdpInitiated?: boolean;
    /**
     * EncryptionKeyPair is a key pair used for decrypting SAML assertions.
     */
    assertionKeyPair?: outputs.GetSamlConnectorSpecAssertionKeyPair;
    /**
     * AttributesToRoles is a list of mappings of attribute statements to roles.
     */
    attributesToRoles: outputs.GetSamlConnectorSpecAttributesToRole[];
    /**
     * Audience uniquely identifies our service provider.
     */
    audience: string;
    /**
     * Cert is the identity provider certificate PEM. IDP signs `<Response>` responses using this certificate.
     */
    cert?: string;
    /**
     * ClientRedirectSettings defines which client redirect URLs are allowed for non-browser SSO logins other than the standard localhost ones.
     */
    clientRedirectSettings?: outputs.GetSamlConnectorSpecClientRedirectSettings;
    /**
     * Display controls how this connector is displayed.
     */
    display?: string;
    /**
     * EntityDescriptor is XML with descriptor. It can be used to supply configuration parameters in one XML file rather than supplying them in the individual elements.
     */
    entityDescriptor?: string;
    /**
     * EntityDescriptorURL is a URL that supplies a configuration XML.
     */
    entityDescriptorUrl?: string;
    /**
     * ForceAuthn specified whether re-authentication should be forced on login. UNSPECIFIED is treated as NO.
     */
    forceAuthn?: number;
    /**
     * Issuer is the identity provider issuer.
     */
    issuer: string;
    /**
     * MFASettings contains settings to enable SSO MFA checks through this auth connector.
     */
    mfa?: outputs.GetSamlConnectorSpecMfa;
    /**
     * Provider is the external identity provider.
     */
    provider?: string;
    /**
     * ServiceProviderIssuer is the issuer of the service provider (Teleport).
     */
    serviceProviderIssuer: string;
    /**
     * SigningKeyPair is an x509 key pair used to sign AuthnRequest.
     */
    signingKeyPair: outputs.GetSamlConnectorSpecSigningKeyPair;
    /**
     * SingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out). If this is not provided, SLO is disabled.
     */
    singleLogoutUrl?: string;
    /**
     * SSO is the URL of the identity provider's SSO service.
     */
    sso: string;
}

export interface GetSamlConnectorSpecAssertionKeyPair {
    /**
     * Cert is a PEM-encoded x509 certificate.
     */
    cert: string;
    /**
     * PrivateKey is a PEM encoded x509 private key.
     */
    privateKey: string;
}

export interface GetSamlConnectorSpecAttributesToRole {
    /**
     * Name is an attribute statement name.
     */
    name?: string;
    /**
     * Roles is a list of static teleport roles to map to.
     */
    roles?: string[];
    /**
     * Value is an attribute statement value to match.
     */
    value?: string;
}

export interface GetSamlConnectorSpecClientRedirectSettings {
    /**
     * a list of hostnames allowed for https client redirect URLs
     */
    allowedHttpsHostnames?: string[];
    /**
     * a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
     */
    insecureAllowedCidrRanges?: string[];
}

export interface GetSamlConnectorSpecMfa {
    /**
     * Cert is the identity provider certificate PEM. IDP signs `<Response>` responses using this certificate.
     */
    cert?: string;
    /**
     * Enabled specified whether this SAML connector supports MFA checks. Defaults to false.
     */
    enabled?: boolean;
    /**
     * EntityDescriptor is XML with descriptor. It can be used to supply configuration parameters in one XML file rather than supplying them in the individual elements. Usually set from EntityDescriptorUrl.
     */
    entityDescriptor?: string;
    /**
     * EntityDescriptorUrl is a URL that supplies a configuration XML.
     */
    entityDescriptorUrl?: string;
    /**
     * ForceAuthn specified whether re-authentication should be forced for MFA checks. UNSPECIFIED is treated as YES to always re-authentication for MFA checks. This should only be set to NO if the IdP is setup to perform MFA checks on top of active user sessions.
     */
    forceAuthn?: number;
    /**
     * Issuer is the identity provider issuer. Usually set from EntityDescriptor.
     */
    issuer?: string;
    /**
     * SSO is the URL of the identity provider's SSO service. Usually set from EntityDescriptor.
     */
    sso?: string;
}

export interface GetSamlConnectorSpecSigningKeyPair {
    /**
     * Cert is a PEM-encoded x509 certificate.
     */
    cert: string;
    /**
     * PrivateKey is a PEM encoded x509 private key.
     */
    privateKey: string;
}

export interface GetSessionRecordingConfigMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetSessionRecordingConfigSpec {
    /**
     * Mode controls where (or if) the session is recorded.
     */
    mode: string;
    /**
     * ProxyChecksHostKeys is used to control if the proxy will check host keys when in recording mode.
     */
    proxyChecksHostKeys?: boolean;
}

export interface GetStaticHostUserMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetStaticHostUserSpec {
    matchers: outputs.GetStaticHostUserSpecMatcher[];
}

export interface GetStaticHostUserSpecMatcher {
    /**
     * default_shell is the new user's default shell
     */
    defaultShell?: string;
    /**
     * gid is the new user's gid.
     */
    gid?: number;
    /**
     * groups is a list of additional groups to add the user to.
     */
    groups?: string[];
    /**
     * node_labels is a map of node labels that will create a user from this resource.
     */
    nodeLabels?: outputs.GetStaticHostUserSpecMatcherNodeLabel[];
    /**
     * node_labels_expression is a predicate expression to create a user from this resource.
     */
    nodeLabelsExpression?: string;
    /**
     * sudoers is a list of sudoer entries to add.
     */
    sudoers?: string[];
    /**
     * take_ownership_if_user_exists will take ownership of existing, unmanaged users
     */
    takeOwnershipIfUserExists?: boolean;
    /**
     * uid is the new user's uid.
     */
    uid?: number;
}

export interface GetStaticHostUserSpecMatcherNodeLabel {
    /**
     * The name of the label.
     */
    name: string;
    /**
     * The values associated with the label.
     */
    values: string[];
}

export interface GetTrustedClusterMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetTrustedClusterSpec {
    /**
     * Enabled is a bool that indicates if the TrustedCluster is enabled or disabled. Setting Enabled to false has a side effect of deleting the user and host certificate authority (CA).
     */
    enabled?: boolean;
    /**
     * RoleMap specifies role mappings to remote roles.
     */
    roleMaps?: outputs.GetTrustedClusterSpecRoleMap[];
    /**
     * Roles is a list of roles that users will be assuming when connecting to this cluster.
     */
    roles?: string[];
    /**
     * Token is the authorization token provided by another cluster needed by this cluster to join.
     */
    token?: string;
    /**
     * ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If not set, it is derived from `<metadata.name>:<default reverse tunnel port>`.
     */
    tunnelAddr?: string;
    /**
     * ProxyAddress is the address of the web proxy server of the cluster to join. If not set, it is derived from `<metadata.name>:<default web proxy server port>`.
     */
    webProxyAddr?: string;
}

export interface GetTrustedClusterSpecRoleMap {
    /**
     * Local specifies local roles to map to
     */
    locals?: string[];
    /**
     * Remote specifies remote role name to map from
     */
    remote?: string;
}

export interface GetTrustedDeviceMetadata {
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name?: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetTrustedDeviceSpec {
    assetTag: string;
    enrollStatus: string;
    osType: string;
    owner?: string;
    source?: outputs.GetTrustedDeviceSpecSource;
}

export interface GetTrustedDeviceSpecSource {
    name?: string;
    origin?: string;
}

export interface GetUserMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetUserSpec {
    /**
     * GithubIdentities list associated Github OAuth2 identities that let user log in using externally verified identity
     */
    githubIdentities?: outputs.GetUserSpecGithubIdentity[];
    /**
     * OIDCIdentities lists associated OpenID Connect identities that let user log in using externally verified identity
     */
    oidcIdentities?: outputs.GetUserSpecOidcIdentity[];
    /**
     * Roles is a list of roles assigned to user
     */
    roles?: string[];
    /**
     * SAMLIdentities lists associated SAML identities that let user log in using externally verified identity
     */
    samlIdentities?: outputs.GetUserSpecSamlIdentity[];
    /**
     * Traits are key/value pairs received from an identity provider (through OIDC claims or SAML assertions) or from a system administrator for local accounts. Traits are used to populate role variables.
     */
    traits?: {[key: string]: string[]};
    /**
     * TrustedDeviceIDs contains the IDs of trusted devices enrolled by the user.  Note that SSO users are transient and thus may contain an empty TrustedDeviceIDs field, even though the user->device association exists under the Device Trust subsystem. Do not rely on this field to determine device associations or ownership, it exists for legacy/informative purposes only.  Managed by the Device Trust subsystem, avoid manual edits.
     */
    trustedDeviceIds?: string[];
}

export interface GetUserSpecGithubIdentity {
    /**
     * ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
     */
    connectorId?: string;
    /**
     * SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
     */
    samlSingleLogoutUrl?: string;
    /**
     * UserID is the ID of the identity. Some connectors like GitHub have an unique ID apart from the username.
     */
    userId?: string;
    /**
     * Username is username supplied by external identity provider
     */
    username?: string;
}

export interface GetUserSpecOidcIdentity {
    /**
     * ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
     */
    connectorId?: string;
    /**
     * SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
     */
    samlSingleLogoutUrl?: string;
    /**
     * UserID is the ID of the identity. Some connectors like GitHub have an unique ID apart from the username.
     */
    userId?: string;
    /**
     * Username is username supplied by external identity provider
     */
    username?: string;
}

export interface GetUserSpecSamlIdentity {
    /**
     * ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
     */
    connectorId?: string;
    /**
     * SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
     */
    samlSingleLogoutUrl?: string;
    /**
     * UserID is the ID of the identity. Some connectors like GitHub have an unique ID apart from the username.
     */
    userId?: string;
    /**
     * Username is username supplied by external identity provider
     */
    username?: string;
}

export interface GetUserStatus {
    /**
     * mfa_weakest_device reflects what the system knows about the user's weakest MFA device. Note that this is a "best effort" property, in that it can be UNSPECIFIED.
     */
    mfaWeakestDevice?: number;
    /**
     * password_state reflects what the system knows about the user's password. Note that this is a "best effort" property, in that it can be UNSPECIFIED for users who were created before this property was introduced and didn't perform any password-related activity since then. See RFD 0159 for details. Do NOT use this value for authentication purposes!
     */
    passwordState?: number;
}

export interface GetWorkloadIdentityMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name?: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GetWorkloadIdentitySpec {
    /**
     * The rules which are evaluated before the WorkloadIdentity can be issued.
     */
    rules?: outputs.GetWorkloadIdentitySpecRules;
    /**
     * Configuration pertaining to the issuance of SPIFFE-compatible workload identity credentials.
     */
    spiffe?: outputs.GetWorkloadIdentitySpecSpiffe;
}

export interface GetWorkloadIdentitySpecRules {
    /**
     * A list of rules used to determine if a WorkloadIdentity can be issued. If none are provided, it will be considered a pass. If any are provided, then at least one must pass for the rules to be considered passed.
     */
    allows?: outputs.GetWorkloadIdentitySpecRulesAllow[];
}

export interface GetWorkloadIdentitySpecRulesAllow {
    /**
     * The conditions that must be met for this rule to be considered passed.  Mutually exclusive with expression.
     */
    conditions?: outputs.GetWorkloadIdentitySpecRulesAllowCondition[];
    /**
     * An expression written in Teleport's predicate language that must evaluate to true for this rule to be considered passed.  Mutually exclusive with conditions.
     */
    expression?: string;
}

export interface GetWorkloadIdentitySpecRulesAllowCondition {
    /**
     * The name of the attribute to evaluate the condition against.
     */
    attribute?: string;
    /**
     * The attribute casted to a string must be equal to the value.
     */
    eq?: outputs.GetWorkloadIdentitySpecRulesAllowConditionEq;
    /**
     * The attribute casted to a string must be in the list of values.
     */
    in?: outputs.GetWorkloadIdentitySpecRulesAllowConditionIn;
    /**
     * The attribute casted to a string must not be equal to the value.
     */
    notEq?: outputs.GetWorkloadIdentitySpecRulesAllowConditionNotEq;
    /**
     * The attribute casted to a string must not be in the list of values.
     */
    notIn?: outputs.GetWorkloadIdentitySpecRulesAllowConditionNotIn;
}

export interface GetWorkloadIdentitySpecRulesAllowConditionEq {
    /**
     * The value to compare the attribute against.
     */
    value?: string;
}

export interface GetWorkloadIdentitySpecRulesAllowConditionIn {
    /**
     * The list of values to compare the attribute against.
     */
    values?: string[];
}

export interface GetWorkloadIdentitySpecRulesAllowConditionNotEq {
    /**
     * The value to compare the attribute against.
     */
    value?: string;
}

export interface GetWorkloadIdentitySpecRulesAllowConditionNotIn {
    /**
     * The list of values to compare the attribute against.
     */
    values?: string[];
}

export interface GetWorkloadIdentitySpecSpiffe {
    /**
     * A freeform text field which is provided to workloads along with a credential produced by this WorkloadIdentity. This can be used to provide additional context that can be used to select between multiple credentials.
     */
    hint?: string;
    /**
     * The path of the SPIFFE ID that will be issued to the workload.  This should be prefixed with a forward-slash ("/").  This field supports templating using attributes.
     */
    id?: string;
    /**
     * Configuration specific to JWT-SVIDs.
     */
    jwt?: outputs.GetWorkloadIdentitySpecSpiffeJwt;
    /**
     * Configuration specific to X509-SVIDs.
     */
    x509?: outputs.GetWorkloadIdentitySpecSpiffeX509;
}

export interface GetWorkloadIdentitySpecSpiffeJwt {
    /**
     * Control the maximum TTL of JWT-SVIDs issued using this WorkloadIdentity.  If a JWT-SVID is requested with a TTL greater than this value, then the returned JWT-SVID will have a TTL of this value.  Defaults to 24 hours. The maximum this value can be set to is 24 hours.
     */
    maximumTtl?: string;
}

export interface GetWorkloadIdentitySpecSpiffeX509 {
    /**
     * The DNS Subject Alternative Names (SANs) that should be included in an X509-SVID issued using this WorkloadIdentity.  Each entry in this list supports templating using attributes.
     */
    dnsSans?: string[];
    /**
     * Control the maximum TTL of X509-SVIDs issued using this WorkloadIdentity.  If a X509-SVID is requested with a TTL greater than this value, then the returned X509-SVID will have a TTL of this value.  Defaults to 24 hours. The maximum this value can be set to is 14 days.
     */
    maximumTtl?: string;
    /**
     * Used to configure the Subject Distinguished Name (DN) of the X509-SVID.  In most circumstances, it is recommended to prefer relying on the SPIFFE ID encoded in the URI SAN. However, the Subject DN may be needed to support legacy systems designed for X509 and not SPIFFE/WIMSE.  If not provided, the X509-SVID will be issued with an empty Subject DN.
     */
    subjectTemplate?: outputs.GetWorkloadIdentitySpecSpiffeX509SubjectTemplate;
}

export interface GetWorkloadIdentitySpecSpiffeX509SubjectTemplate {
    /**
     * Common Name (CN) - 2.5.4.3 If empty, the RDN will be omitted from the DN.
     */
    commonName?: string;
    /**
     * Organization (O) - 2.5.4.10 If empty, the RDN will be omitted from the DN.
     */
    organization?: string;
    /**
     * Organizational Unit (OU) - 2.5.4.11 If empty, the RDN will be omitted from the DN.
     */
    organizationalUnit?: string;
}

export interface GithubConnectorMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface GithubConnectorSpec {
    /**
     * APIEndpointURL is the URL of the API endpoint of the Github instance this connector is for.
     */
    apiEndpointUrl?: string;
    /**
     * ClientID is the Github OAuth app client ID.
     */
    clientId: string;
    /**
     * ClientRedirectSettings defines which client redirect URLs are allowed for non-browser SSO logins other than the standard localhost ones.
     */
    clientRedirectSettings?: outputs.GithubConnectorSpecClientRedirectSettings;
    /**
     * ClientSecret is the Github OAuth app client secret.
     */
    clientSecret: string;
    /**
     * Display is the connector display name.
     */
    display?: string;
    /**
     * EndpointURL is the URL of the GitHub instance this connector is for.
     */
    endpointUrl?: string;
    /**
     * RedirectURL is the authorization callback URL.
     */
    redirectUrl?: string;
    /**
     * TeamsToLogins maps Github team memberships onto allowed logins/roles.  DELETE IN 11.0.0 Deprecated: use GithubTeamsToRoles instead.
     */
    teamsToLogins?: outputs.GithubConnectorSpecTeamsToLogin[];
    /**
     * TeamsToRoles maps Github team memberships onto allowed roles.
     */
    teamsToRoles?: outputs.GithubConnectorSpecTeamsToRole[];
}

export interface GithubConnectorSpecClientRedirectSettings {
    /**
     * a list of hostnames allowed for https client redirect URLs
     */
    allowedHttpsHostnames?: string[];
    /**
     * a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
     */
    insecureAllowedCidrRanges?: string[];
}

export interface GithubConnectorSpecTeamsToLogin {
    /**
     * KubeGroups is a list of allowed kubernetes groups for this org/team.
     */
    kubernetesGroups?: string[];
    /**
     * KubeUsers is a list of allowed kubernetes users to impersonate for this org/team.
     */
    kubernetesUsers?: string[];
    /**
     * Logins is a list of allowed logins for this org/team.
     */
    logins?: string[];
    /**
     * Organization is a Github organization a user belongs to.
     */
    organization?: string;
    /**
     * Team is a team within the organization a user belongs to.
     */
    team?: string;
}

export interface GithubConnectorSpecTeamsToRole {
    /**
     * Organization is a Github organization a user belongs to.
     */
    organization?: string;
    /**
     * Roles is a list of allowed logins for this org/team.
     */
    roles?: string[];
    /**
     * Team is a team within the organization a user belongs to.
     */
    team?: string;
}

export interface InstallerMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface InstallerSpec {
    /**
     * Script represents the contents of a installer shell script
     */
    script: string;
}

export interface LoginRuleMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface LoginRuleTraitsMap {
    values?: string[];
}

export interface OidcConnectorMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface OidcConnectorSpec {
    /**
     * ACR is an Authentication Context Class Reference value. The meaning of the ACR value is context-specific and varies for identity providers.
     */
    acrValues?: string;
    /**
     * AllowUnverifiedEmail tells the connector to accept OIDC users with unverified emails.
     */
    allowUnverifiedEmail?: boolean;
    /**
     * ClaimsToRoles specifies a dynamic mapping from claims to roles.
     */
    claimsToRoles?: outputs.OidcConnectorSpecClaimsToRole[];
    /**
     * ClientID is the id of the authentication client (Teleport Auth Service).
     */
    clientId?: string;
    /**
     * ClientRedirectSettings defines which client redirect URLs are allowed for non-browser SSO logins other than the standard localhost ones.
     */
    clientRedirectSettings?: outputs.OidcConnectorSpecClientRedirectSettings;
    /**
     * ClientSecret is used to authenticate the client.
     */
    clientSecret?: string;
    /**
     * Display is the friendly name for this provider.
     */
    display?: string;
    /**
     * GoogleAdminEmail is the email of a google admin to impersonate.
     */
    googleAdminEmail?: string;
    /**
     * GoogleServiceAccount is a string containing google service account credentials.
     */
    googleServiceAccount?: string;
    /**
     * GoogleServiceAccountURI is a path to a google service account uri.
     */
    googleServiceAccountUri?: string;
    /**
     * IssuerURL is the endpoint of the provider, e.g. https://accounts.google.com.
     */
    issuerUrl?: string;
    maxAge?: string;
    /**
     * MFASettings contains settings to enable SSO MFA checks through this auth connector.
     */
    mfa?: outputs.OidcConnectorSpecMfa;
    /**
     * Prompt is an optional OIDC prompt. An empty string omits prompt. If not specified, it defaults to select_account for backwards compatibility.
     */
    prompt?: string;
    /**
     * Provider is the external identity provider.
     */
    provider?: string;
    /**
     * RedirectURLs is a list of callback URLs which the identity provider can use to redirect the client back to the Teleport Proxy to complete authentication. This list should match the URLs on the provider's side. The URL used for a given auth request will be chosen to match the requesting Proxy's public address. If there is no match, the first url in the list will be used.
     */
    redirectUrls?: string[];
    /**
     * Scope specifies additional scopes set by provider.
     */
    scopes?: string[];
    /**
     * UsernameClaim specifies the name of the claim from the OIDC connector to be used as the user's username.
     */
    usernameClaim?: string;
}

export interface OidcConnectorSpecClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface OidcConnectorSpecClientRedirectSettings {
    /**
     * a list of hostnames allowed for https client redirect URLs
     */
    allowedHttpsHostnames?: string[];
    /**
     * a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
     */
    insecureAllowedCidrRanges?: string[];
}

export interface OidcConnectorSpecMfa {
    /**
     * AcrValues are Authentication Context Class Reference values. The meaning of the ACR value is context-specific and varies for identity providers. Some identity providers support MFA specific contexts, such Okta with its "phr" (phishing-resistant) ACR.
     */
    acrValues?: string;
    /**
     * ClientID is the OIDC OAuth app client ID.
     */
    clientId?: string;
    /**
     * ClientSecret is the OIDC OAuth app client secret.
     */
    clientSecret?: string;
    /**
     * Enabled specified whether this OIDC connector supports MFA checks. Defaults to false.
     */
    enabled?: boolean;
    /**
     * MaxAge is the amount of time in nanoseconds that an IdP session is valid for. Defaults to 0 to always force re-authentication for MFA checks. This should only be set to a non-zero value if the IdP is setup to perform MFA checks on top of active user sessions.
     */
    maxAge?: string;
    /**
     * Prompt is an optional OIDC prompt. An empty string omits prompt. If not specified, it defaults to select_account for backwards compatibility.
     */
    prompt?: string;
}

export interface OktaImportRuleMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface OktaImportRuleSpec {
    /**
     * Mappings is a list of matches that will map match conditions to labels.
     */
    mappings?: outputs.OktaImportRuleSpecMapping[];
    /**
     * Priority represents the priority of the rule application. Lower numbered rules will be applied first.
     */
    priority?: number;
}

export interface OktaImportRuleSpecMapping {
    /**
     * AddLabels specifies which labels to add if any of the previous matches match.
     */
    addLabels?: {[key: string]: string};
    /**
     * Match is a set of matching rules for this mapping. If any of these match, then the mapping will be applied.
     */
    matches?: outputs.OktaImportRuleSpecMappingMatch[];
}

export interface OktaImportRuleSpecMappingMatch {
    /**
     * AppIDs is a list of app IDs to match against.
     */
    appIds?: string[];
    /**
     * AppNameRegexes is a list of regexes to match against app names.
     */
    appNameRegexes?: string[];
    /**
     * GroupIDs is a list of group IDs to match against.
     */
    groupIds?: string[];
    /**
     * GroupNameRegexes is a list of regexes to match against group names.
     */
    groupNameRegexes?: string[];
}

export interface ProvisionTokenMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface ProvisionTokenSpec {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecAllow[];
    /**
     * AWSIIDTTL is the TTL to use for AWS EC2 Instance Identity Documents used to join the cluster with this token.
     */
    awsIidTtl: string;
    /**
     * Azure allows the configuration of options specific to the "azure" join method.
     */
    azure?: outputs.ProvisionTokenSpecAzure;
    /**
     * Bitbucket allows the configuration of options specific to the "bitbucket" join method.
     */
    bitbucket?: outputs.ProvisionTokenSpecBitbucket;
    /**
     * BotName is the name of the bot this token grants access to, if any
     */
    botName?: string;
    /**
     * CircleCI allows the configuration of options specific to the "circleci" join method.
     */
    circleci?: outputs.ProvisionTokenSpecCircleci;
    /**
     * GCP allows the configuration of options specific to the "gcp" join method.
     */
    gcp?: outputs.ProvisionTokenSpecGcp;
    /**
     * GitHub allows the configuration of options specific to the "github" join method.
     */
    github?: outputs.ProvisionTokenSpecGithub;
    /**
     * GitLab allows the configuration of options specific to the "gitlab" join method.
     */
    gitlab?: outputs.ProvisionTokenSpecGitlab;
    /**
     * JoinMethod is the joining method required in order to use this token. Supported joining methods include: azure, circleci, ec2, gcp, github, gitlab, iam, kubernetes, spacelift, token, tpm
     */
    joinMethod?: string;
    /**
     * Kubernetes allows the configuration of options specific to the "kubernetes" join method.
     */
    kubernetes?: outputs.ProvisionTokenSpecKubernetes;
    /**
     * Oracle allows the configuration of options specific to the "oracle" join method.
     */
    oracle?: outputs.ProvisionTokenSpecOracle;
    /**
     * Roles is a list of roles associated with the token, that will be converted to metadata in the SSH and X509 certificates issued to the user of the token
     */
    roles: string[];
    /**
     * Spacelift allows the configuration of options specific to the "spacelift" join method.
     */
    spacelift?: outputs.ProvisionTokenSpecSpacelift;
    /**
     * SuggestedAgentMatcherLabels is a set of labels to be used by agents to match on resources. When an agent uses this token, the agent should monitor resources that match those labels. For databases, this means adding the labels to `db_service.resources.labels`. Currently, only node-join scripts create a configuration according to the suggestion.
     */
    suggestedAgentMatcherLabels?: {[key: string]: string[]};
    /**
     * SuggestedLabels is a set of labels that resources should set when using this token to enroll themselves in the cluster. Currently, only node-join scripts create a configuration according to the suggestion.
     */
    suggestedLabels?: {[key: string]: string[]};
    terraformCloud?: outputs.ProvisionTokenSpecTerraformCloud;
    /**
     * TPM allows the configuration of options specific to the "tpm" join method.
     */
    tpm?: outputs.ProvisionTokenSpecTpm;
}

export interface ProvisionTokenSpecAllow {
    /**
     * AWSAccount is the AWS account ID.
     */
    awsAccount?: string;
    /**
     * AWSARN is used for the IAM join method, the AWS identity of joining nodes must match this ARN. Supports wildcards "*" and "?".
     */
    awsArn?: string;
    /**
     * AWSRegions is used for the EC2 join method and is a list of AWS regions a node is allowed to join from.
     */
    awsRegions?: string[];
    /**
     * AWSRole is used for the EC2 join method and is the ARN of the AWS role that the Auth Service will assume in order to call the ec2 API.
     */
    awsRole?: string;
}

export interface ProvisionTokenSpecAzure {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecAzureAllow[];
}

export interface ProvisionTokenSpecAzureAllow {
    /**
     * ResourceGroups is a list of Azure resource groups the node is allowed to join from.
     */
    resourceGroups?: string[];
    /**
     * Subscription is the Azure subscription.
     */
    subscription?: string;
}

export interface ProvisionTokenSpecBitbucket {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecBitbucketAllow[];
    /**
     * Audience is a Bitbucket-specified audience value for this token. It is unique to each Bitbucket repository, and must be set to the value as written in the Pipelines > OpenID Connect section of the repository settings.
     */
    audience?: string;
    /**
     * IdentityProviderURL is a Bitbucket-specified issuer URL for incoming OIDC tokens. It is unique to each Bitbucket repository, and must be set to the value as written in the Pipelines > OpenID Connect section of the repository settings.
     */
    identityProviderUrl?: string;
}

export interface ProvisionTokenSpecBitbucketAllow {
    /**
     * BranchName is the name of the branch on which this pipeline executed.
     */
    branchName?: string;
    /**
     * DeploymentEnvironmentUUID is the UUID of the deployment environment targeted by this pipelines run, if any. These values may be found in the "Pipelines > OpenID Connect > Deployment environments" section of the repository settings.
     */
    deploymentEnvironmentUuid?: string;
    /**
     * RepositoryUUID is the UUID of the repository for which this token was issued. Bitbucket UUIDs must begin and end with braces, e.g. `{...}`. This value may be found in the Pipelines > OpenID Connect section of the repository settings.
     */
    repositoryUuid?: string;
    /**
     * WorkspaceUUID is the UUID of the workspace for which this token was issued. Bitbucket UUIDs must begin and end with braces, e.g. `{...}`. This value may be found in the Pipelines > OpenID Connect section of the repository settings.
     */
    workspaceUuid?: string;
}

export interface ProvisionTokenSpecCircleci {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecCircleciAllow[];
    organizationId?: string;
}

export interface ProvisionTokenSpecCircleciAllow {
    contextId?: string;
    projectId?: string;
}

export interface ProvisionTokenSpecGcp {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecGcpAllow[];
}

export interface ProvisionTokenSpecGcpAllow {
    /**
     * Locations is a list of regions (e.g. "us-west1") and/or zones (e.g. "us-west1-b").
     */
    locations?: string[];
    /**
     * ProjectIDs is a list of project IDs (e.g. `<example-id-123456>`).
     */
    projectIds?: string[];
    /**
     * ServiceAccounts is a list of service account emails (e.g. `<project-number>-compute@developer.gserviceaccount.com`).
     */
    serviceAccounts?: string[];
}

export interface ProvisionTokenSpecGithub {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecGithubAllow[];
    /**
     * EnterpriseServerHost allows joining from runners associated with a GitHub Enterprise Server instance. When unconfigured, tokens will be validated against github.com, but when configured to the host of a GHES instance, then the tokens will be validated against host.  This value should be the hostname of the GHES instance, and should not include the scheme or a path. The instance must be accessible over HTTPS at this hostname and the certificate must be trusted by the Auth Service.
     */
    enterpriseServerHost?: string;
    /**
     * EnterpriseSlug allows the slug of a GitHub Enterprise organisation to be included in the expected issuer of the OIDC tokens. This is for compatibility with the `include_enterprise_slug` option in GHE.  This field should be set to the slug of your enterprise if this is enabled. If this is not enabled, then this field must be left empty. This field cannot be specified if `enterprise_server_host` is specified.  See https://docs.github.com/en/enterprise-cloud@latest/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#customizing-the-issuer-value-for-an-enterprise for more information about customized issuer values.
     */
    enterpriseSlug?: string;
    /**
     * StaticJWKS disables fetching of the GHES signing keys via the JWKS/OIDC endpoints, and allows them to be directly specified. This allows joining from GitHub Actions in GHES instances that are not reachable by the Teleport Auth Service.
     */
    staticJwks?: string;
}

export interface ProvisionTokenSpecGithubAllow {
    /**
     * The personal account that initiated the workflow run.
     */
    actor?: string;
    /**
     * The name of the environment used by the job.
     */
    environment?: string;
    /**
     * The git ref that triggered the workflow run.
     */
    ref?: string;
    /**
     * The type of ref, for example: "branch".
     */
    refType?: string;
    /**
     * The repository from where the workflow is running. This includes the name of the owner e.g `gravitational/teleport`
     */
    repository?: string;
    /**
     * The name of the organization in which the repository is stored.
     */
    repositoryOwner?: string;
    /**
     * Sub also known as Subject is a string that roughly uniquely identifies the workload. The format of this varies depending on the type of github action run.
     */
    sub?: string;
    /**
     * The name of the workflow.
     */
    workflow?: string;
}

export interface ProvisionTokenSpecGitlab {
    /**
     * Allow is a list of TokenRules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecGitlabAllow[];
    /**
     * Domain is the domain of your GitLab instance. This will default to `gitlab.com` - but can be set to the domain of your self-hosted GitLab e.g `gitlab.example.com`.
     */
    domain?: string;
    /**
     * StaticJWKS disables fetching of the GitLab signing keys via the JWKS/OIDC endpoints, and allows them to be directly specified. This allows joining from GitLab CI instances that are not reachable by the Teleport Auth Service.
     */
    staticJwks?: string;
}

export interface ProvisionTokenSpecGitlabAllow {
    /**
     * CIConfigRefURI is the ref path to the top-level pipeline definition, for example, gitlab.example.com/my-group/my-project//.gitlab-ci.yml@refs/heads/main.
     */
    ciConfigRefUri?: string;
    /**
     * CIConfigSHA is the git commit SHA for the ci_config_ref_uri.
     */
    ciConfigSha?: string;
    /**
     * DeploymentTier is the deployment tier of the environment the job specifies
     */
    deploymentTier?: string;
    /**
     * Environment limits access by the environment the job deploys to (if one is associated)
     */
    environment?: string;
    /**
     * EnvironmentProtected is true if the Git ref is protected, false otherwise.
     */
    environmentProtected?: boolean;
    /**
     * NamespacePath is used to limit access to jobs in a group or user's projects. Example: `mygroup`  This field supports "glob-style" matching: - Use '*' to match zero or more characters. - Use '?' to match any single character.
     */
    namespacePath?: string;
    /**
     * PipelineSource limits access by the job pipeline source type. https://docs.gitlab.com/ee/ci/jobs/job_control.html#common-if-clauses-for-rules Example: `web`
     */
    pipelineSource?: string;
    /**
     * ProjectPath is used to limit access to jobs belonging to an individual project. Example: `mygroup/myproject`  This field supports "glob-style" matching: - Use '*' to match zero or more characters. - Use '?' to match any single character.
     */
    projectPath?: string;
    /**
     * ProjectVisibility is the visibility of the project where the pipeline is running. Can be internal, private, or public.
     */
    projectVisibility?: string;
    /**
     * Ref allows access to be limited to jobs triggered by a specific git ref. Ensure this is used in combination with ref_type.  This field supports "glob-style" matching: - Use '*' to match zero or more characters. - Use '?' to match any single character.
     */
    ref?: string;
    /**
     * RefProtected is true if the Git ref is protected, false otherwise.
     */
    refProtected?: boolean;
    /**
     * RefType allows access to be limited to jobs triggered by a specific git ref type. Example: `branch` or `tag`
     */
    refType?: string;
    /**
     * Sub roughly uniquely identifies the workload. Example: `project_path:mygroup/my-project:ref_type:branch:ref:main` project_path:GROUP/PROJECT:ref_type:TYPE:ref:BRANCH_NAME  This field supports "glob-style" matching: - Use '*' to match zero or more characters. - Use '?' to match any single character.
     */
    sub?: string;
    /**
     * UserEmail is the email of the user executing the job
     */
    userEmail?: string;
    /**
     * UserID is the ID of the user executing the job
     */
    userId?: string;
    /**
     * UserLogin is the username of the user executing the job
     */
    userLogin?: string;
}

export interface ProvisionTokenSpecKubernetes {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecKubernetesAllow[];
    /**
     * StaticJWKS is the configuration specific to the `static_jwks` type.
     */
    staticJwks?: outputs.ProvisionTokenSpecKubernetesStaticJwks;
    /**
     * Type controls which behavior should be used for validating the Kubernetes Service Account token. Support values: - `in_cluster` - `static_jwks` If unset, this defaults to `in_cluster`.
     */
    type?: string;
}

export interface ProvisionTokenSpecKubernetesAllow {
    /**
     * ServiceAccount is the namespaced name of the Kubernetes service account. Its format is "namespace:service-account".
     */
    serviceAccount?: string;
}

export interface ProvisionTokenSpecKubernetesStaticJwks {
    /**
     * JWKS should be the JSON Web Key Set formatted public keys of that the Kubernetes Cluster uses to sign service account tokens. This can be fetched from /openid/v1/jwks on the Kubernetes API Server.
     */
    jwks?: string;
}

export interface ProvisionTokenSpecOracle {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecOracleAllow[];
}

export interface ProvisionTokenSpecOracleAllow {
    /**
     * ParentCompartments is a list of the OCIDs of compartments an instance is allowed to join from. Only direct parents are allowed, i.e. no nested compartments. If empty, any compartment is allowed.
     */
    parentCompartments?: string[];
    /**
     * Regions is a list of regions an instance is allowed to join from. Both full region names ("us-phoenix-1") and abbreviations ("phx") are allowed. If empty, any region is allowed.
     */
    regions?: string[];
    /**
     * Tenancy is the OCID of the instance's tenancy. Required.
     */
    tenancy?: string;
}

export interface ProvisionTokenSpecSpacelift {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecSpaceliftAllow[];
    /**
     * Hostname is the hostname of the Spacelift tenant that tokens will originate from. E.g `example.app.spacelift.io`
     */
    hostname?: string;
}

export interface ProvisionTokenSpecSpaceliftAllow {
    /**
     * CallerID is the ID of the caller, ie. the stack or module that generated the run.
     */
    callerId?: string;
    /**
     * CallerType is the type of the caller, ie. the entity that owns the run - either `stack` or `module`.
     */
    callerType?: string;
    /**
     * Scope is the scope of the token - either `read` or `write`. See https://docs.spacelift.io/integrations/cloud-providers/oidc/#about-scopes
     */
    scope?: string;
    /**
     * SpaceID is the ID of the space in which the run that owns the token was executed.
     */
    spaceId?: string;
}

export interface ProvisionTokenSpecTerraformCloud {
    /**
     * Allow is a list of Rules, nodes using this token must match one allow rule to use this token.
     */
    allows?: outputs.ProvisionTokenSpecTerraformCloudAllow[];
    audience?: string;
    hostname?: string;
}

export interface ProvisionTokenSpecTerraformCloudAllow {
    organizationId?: string;
    organizationName?: string;
    projectId?: string;
    projectName?: string;
    /**
     * RunPhase is the phase of the run the token was issued for, e.g. `plan` or `apply`
     */
    runPhase?: string;
    workspaceId?: string;
    workspaceName?: string;
}

export interface ProvisionTokenSpecTpm {
    /**
     * Allow is a list of Rules, the presented delegated identity must match one allow rule to permit joining.
     */
    allows?: outputs.ProvisionTokenSpecTpmAllow[];
    /**
     * EKCertAllowedCAs is a list of CA certificates that will be used to validate TPM EKCerts. When specified, joining TPMs must present an EKCert signed by one of the specified CAs. TPMs that do not present an EKCert will be not permitted to join. When unspecified, TPMs will be allowed to join with either an EKCert or an EKPubHash.
     */
    ekcertAllowedCas?: string[];
}

export interface ProvisionTokenSpecTpmAllow {
    /**
     * Description is a human-readable description of the rule. It has no bearing on whether or not a TPM is allowed to join, but can be used to associate a rule with a specific host (e.g the asset tag of the server in which the TPM resides). Example: "build-server-100"
     */
    description?: string;
    /**
     * EKCertificateSerial is the serial number of the EKCert in hexadecimal with colon separated nibbles. This value will not be checked when a TPM does not have an EKCert configured. Example: 73:df:dc:bd:af:ef:8a:d8:15:2e:96:71:7a:3e:7f:a4
     */
    ekCertificateSerial?: string;
    /**
     * EKPublicHash is the SHA256 hash of the EKPub marshaled in PKIX format and encoded in hexadecimal. This value will also be checked when a TPM has submitted an EKCert, and the public key in the EKCert will be used for this check. Example: d4b45864d9d6fabfc568d74f26c35ababde2105337d7af9a6605e1c56c891aa6
     */
    ekPublicHash?: string;
}

export interface RoleMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface RoleSpec {
    /**
     * Allow is the set of conditions evaluated to grant access.
     */
    allow?: outputs.RoleSpecAllow;
    /**
     * Deny is the set of conditions evaluated to deny access. Deny takes priority over allow.
     */
    deny?: outputs.RoleSpecDeny;
    /**
     * Options is for OpenSSH options like agent forwarding.
     */
    options?: outputs.RoleSpecOptions;
}

export interface RoleSpecAllow {
    /**
     * AccountAssignments holds the list of account assignments affected by this condition.
     */
    accountAssignments?: outputs.RoleSpecAllowAccountAssignment[];
    /**
     * AppLabels is a map of labels used as part of the RBAC system.
     */
    appLabels?: {[key: string]: string[]};
    /**
     * AppLabelsExpression is a predicate expression used to allow/deny access to Apps.
     */
    appLabelsExpression?: string;
    /**
     * AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
     */
    awsRoleArns?: string[];
    /**
     * AzureIdentities is a list of Azure identities this role is allowed to assume.
     */
    azureIdentities?: string[];
    /**
     * ClusterLabels is a map of node labels (used to dynamically grant access to clusters).
     */
    clusterLabels?: {[key: string]: string[]};
    /**
     * ClusterLabelsExpression is a predicate expression used to allow/deny access to remote Teleport clusters.
     */
    clusterLabelsExpression?: string;
    /**
     * DatabaseLabels are used in RBAC system to allow/deny access to databases.
     */
    dbLabels?: {[key: string]: string[]};
    /**
     * DatabaseLabelsExpression is a predicate expression used to allow/deny access to Databases.
     */
    dbLabelsExpression?: string;
    /**
     * DatabaseNames is a list of database names this role is allowed to connect to.
     */
    dbNames?: string[];
    /**
     * DatabasePermissions specifies a set of permissions that will be granted to the database user when using automatic database user provisioning.
     */
    dbPermissions?: outputs.RoleSpecAllowDbPermission[];
    /**
     * DatabaseRoles is a list of databases roles for automatic user creation.
     */
    dbRoles?: string[];
    /**
     * DatabaseServiceLabels are used in RBAC system to allow/deny access to Database Services.
     */
    dbServiceLabels?: {[key: string]: string[]};
    /**
     * DatabaseServiceLabelsExpression is a predicate expression used to allow/deny access to Database Services.
     */
    dbServiceLabelsExpression?: string;
    /**
     * DatabaseUsers is a list of databases users this role is allowed to connect as.
     */
    dbUsers?: string[];
    /**
     * DesktopGroups is a list of groups for created desktop users to be added to
     */
    desktopGroups?: string[];
    /**
     * GCPServiceAccounts is a list of GCP service accounts this role is allowed to assume.
     */
    gcpServiceAccounts?: string[];
    /**
     * GitHubPermissions defines GitHub integration related permissions.
     */
    githubPermissions?: outputs.RoleSpecAllowGithubPermission[];
    /**
     * GroupLabels is a map of labels used as part of the RBAC system.
     */
    groupLabels?: {[key: string]: string[]};
    /**
     * GroupLabelsExpression is a predicate expression used to allow/deny access to user groups.
     */
    groupLabelsExpression?: string;
    /**
     * HostGroups is a list of groups for created users to be added to
     */
    hostGroups?: string[];
    /**
     * HostSudoers is a list of entries to include in a users sudoer file
     */
    hostSudoers?: string[];
    /**
     * Impersonate specifies what users and roles this role is allowed to impersonate by issuing certificates or other possible means.
     */
    impersonate?: outputs.RoleSpecAllowImpersonate;
    /**
     * JoinSessions specifies policies to allow users to join other sessions.
     */
    joinSessions?: outputs.RoleSpecAllowJoinSession[];
    /**
     * KubeGroups is a list of kubernetes groups
     */
    kubernetesGroups?: string[];
    /**
     * KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
     */
    kubernetesLabels?: {[key: string]: string[]};
    /**
     * KubernetesLabelsExpression is a predicate expression used to allow/deny access to kubernetes clusters.
     */
    kubernetesLabelsExpression?: string;
    /**
     * KubernetesResources is the Kubernetes Resources this Role grants access to.
     */
    kubernetesResources: outputs.RoleSpecAllowKubernetesResource[];
    /**
     * KubeUsers is an optional kubernetes users to impersonate
     */
    kubernetesUsers?: string[];
    /**
     * Logins is a list of *nix system logins.
     */
    logins?: string[];
    /**
     * NodeLabels is a map of node labels (used to dynamically grant access to nodes).
     */
    nodeLabels?: {[key: string]: string[]};
    /**
     * NodeLabelsExpression is a predicate expression used to allow/deny access to SSH nodes.
     */
    nodeLabelsExpression?: string;
    request?: outputs.RoleSpecAllowRequest;
    /**
     * RequireSessionJoin specifies policies for required users to start a session.
     */
    requireSessionJoins?: outputs.RoleSpecAllowRequireSessionJoin[];
    /**
     * ReviewRequests defines conditions for submitting access reviews.
     */
    reviewRequests?: outputs.RoleSpecAllowReviewRequests;
    /**
     * Rules is a list of rules and their access levels. Rules are a high level construct used for access control.
     */
    rules?: outputs.RoleSpecAllowRule[];
    /**
     * SPIFFE is used to allow or deny access to a role holder to generating a SPIFFE SVID.
     */
    spiffes?: outputs.RoleSpecAllowSpiffe[];
    /**
     * WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
     */
    windowsDesktopLabels?: {[key: string]: string[]};
    /**
     * WindowsDesktopLabelsExpression is a predicate expression used to allow/deny access to Windows desktops.
     */
    windowsDesktopLabelsExpression?: string;
    /**
     * WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
     */
    windowsDesktopLogins?: string[];
    /**
     * WorkloadIdentityLabels controls whether or not specific WorkloadIdentity resources can be invoked. Further authorization controls exist on the WorkloadIdentity resource itself.
     */
    workloadIdentityLabels?: {[key: string]: string[]};
    /**
     * WorkloadIdentityLabelsExpression is a predicate expression used to allow/deny access to issuing a WorkloadIdentity.
     */
    workloadIdentityLabelsExpression?: string;
}

export interface RoleSpecAllowAccountAssignment {
    account?: string;
    permissionSet?: string;
}

export interface RoleSpecAllowDbPermission {
    /**
     * Match is a list of object labels that must be matched for the permission to be granted.
     */
    match?: {[key: string]: string[]};
    /**
     * Permission is the list of string representations of the permission to be given, e.g. SELECT, INSERT, UPDATE, ...
     */
    permissions?: string[];
}

export interface RoleSpecAllowGithubPermission {
    orgs?: string[];
}

export interface RoleSpecAllowImpersonate {
    /**
     * Roles is a list of resources this role is allowed to impersonate
     */
    roles?: string[];
    /**
     * Users is a list of resources this role is allowed to impersonate, could be an empty list or a Wildcard pattern
     */
    users?: string[];
    /**
     * Where specifies optional advanced matcher
     */
    where?: string;
}

export interface RoleSpecAllowJoinSession {
    /**
     * Kinds are the session kinds this policy applies to.
     */
    kinds?: string[];
    /**
     * Modes is a list of permitted participant modes for this policy.
     */
    modes?: string[];
    /**
     * Name is the name of the policy.
     */
    name?: string;
    /**
     * Roles is a list of roles that you can join the session of.
     */
    roles?: string[];
}

export interface RoleSpecAllowKubernetesResource {
    /**
     * Kind specifies the Kubernetes Resource type.
     */
    kind?: string;
    /**
     * Name is the resource name. It supports wildcards.
     */
    name?: string;
    /**
     * Namespace is the resource namespace. It supports wildcards.
     */
    namespace?: string;
    /**
     * Verbs are the allowed Kubernetes verbs for the following resource.
     */
    verbs: string[];
}

export interface RoleSpecAllowRequest {
    /**
     * Annotations is a collection of annotations to be programmatically appended to pending Access Requests at the time of their creation. These annotations serve as a mechanism to propagate extra information to plugins.  Since these annotations support variable interpolation syntax, they also offer a mechanism for forwarding claims from an external identity provider, to a plugin via `{{external.trait_name}}` style substitutions.
     */
    annotations?: {[key: string]: string[]};
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     */
    claimsToRoles?: outputs.RoleSpecAllowRequestClaimsToRole[];
    /**
     * kubernetes_resources can optionally enforce a requester to request only certain kinds of kube resources. Eg: Users can make request to either a resource kind "kube_cluster" or any of its subresources like "namespaces". This field can be defined such that it prevents a user from requesting "kube_cluster" and enforce requesting any of its subresources.
     */
    kubernetesResources?: outputs.RoleSpecAllowRequestKubernetesResource[];
    /**
     * MaxDuration is the amount of time the access will be granted for. If this is zero, the default duration is used.
     */
    maxDuration?: string;
    /**
     * Reason defines settings for the reason for the access provided by the user.
     */
    reason?: outputs.RoleSpecAllowRequestReason;
    /**
     * Roles is the name of roles which will match the request rule.
     */
    roles?: string[];
    /**
     * SearchAsRoles is a list of extra roles which should apply to a user while they are searching for resources as part of a Resource Access Request, and defines the underlying roles which will be requested as part of any Resource Access Request.
     */
    searchAsRoles?: string[];
    /**
     * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but that is not a requirement.
     */
    suggestedReviewers?: string[];
    /**
     * Thresholds is a list of thresholds, one of which must be met in order for reviews to trigger a state-transition.  If no thresholds are provided, a default threshold of 1 for approval and denial is used.
     */
    thresholds?: outputs.RoleSpecAllowRequestThreshold[];
}

export interface RoleSpecAllowRequestClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface RoleSpecAllowRequestKubernetesResource {
    /**
     * kind specifies the Kubernetes Resource type.
     */
    kind?: string;
}

export interface RoleSpecAllowRequestReason {
    /**
     * Mode can be either "required" or "optional". Empty string is treated as "optional". If a role has the request reason mode set to "required", then reason is required for all Access Requests requesting roles or resources allowed by this role. It applies only to users who have this role assigned.
     */
    mode?: string;
}

export interface RoleSpecAllowRequestThreshold {
    /**
     * Approve is the number of matching approvals needed for state-transition.
     */
    approve?: number;
    /**
     * Deny is the number of denials needed for state-transition.
     */
    deny?: number;
    /**
     * Filter is an optional predicate used to determine which reviews count toward this threshold.
     */
    filter?: string;
    /**
     * Name is the optional human-readable name of the threshold.
     */
    name?: string;
}

export interface RoleSpecAllowRequireSessionJoin {
    /**
     * Count is the amount of people that need to be matched for this policy to be fulfilled.
     */
    count?: number;
    /**
     * Filter is a predicate that determines what users count towards this policy.
     */
    filter?: string;
    /**
     * Kinds are the session kinds this policy applies to.
     */
    kinds?: string[];
    /**
     * Modes is the list of modes that may be used to fulfill this policy.
     */
    modes?: string[];
    /**
     * Name is the name of the policy.
     */
    name?: string;
    /**
     * OnLeave is the behaviour that's used when the policy is no longer fulfilled for a live session.
     */
    onLeave?: string;
}

export interface RoleSpecAllowReviewRequests {
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     */
    claimsToRoles?: outputs.RoleSpecAllowReviewRequestsClaimsToRole[];
    /**
     * PreviewAsRoles is a list of extra roles which should apply to a reviewer while they are viewing a Resource Access Request for the purposes of viewing details such as the hostname and labels of requested resources.
     */
    previewAsRoles?: string[];
    /**
     * Roles is the name of roles which may be reviewed.
     */
    roles?: string[];
    /**
     * Where is an optional predicate which further limits which requests are reviewable.
     */
    where?: string;
}

export interface RoleSpecAllowReviewRequestsClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface RoleSpecAllowRule {
    /**
     * Actions specifies optional actions taken when this rule matches
     */
    actions?: string[];
    /**
     * Resources is a list of resources
     */
    resources?: string[];
    /**
     * Verbs is a list of verbs
     */
    verbs?: string[];
    /**
     * Where specifies optional advanced matcher
     */
    where?: string;
}

export interface RoleSpecAllowSpiffe {
    /**
     * DNSSANs specifies matchers for the SPIFFE ID DNS SANs.  Each requested DNS SAN is compared against all matchers configured and if any match, the condition is considered to be met.  The matcher by default allows '*' to be used to indicate zero or more of any character. Prepend '^' and append '$' to instead switch to matching using the Go regex syntax.  Example: *.example.com would match foo.example.com
     */
    dnsSans?: string[];
    /**
     * IPSANs specifies matchers for the SPIFFE ID IP SANs.  Each requested IP SAN is compared against all matchers configured and if any match, the condition is considered to be met.  The matchers should be specified using CIDR notation, it supports IPv4 and IPv6.  Examples: - 10.0.0.0/24 would match 10.0.0.0 to 10.255.255.255 - 10.0.0.42/32 would match only 10.0.0.42
     */
    ipSans?: string[];
    /**
     * Path specifies a matcher for the SPIFFE ID path. It should not include the trust domain and should start with a leading slash.  The matcher by default allows '*' to be used to indicate zero or more of any character. Prepend '^' and append '$' to instead switch to matching using the Go regex syntax.  Example: - /svc/foo/*&#47;bar would match /svc/foo/baz/bar - ^\/svc\/foo\/.*\/bar$ would match /svc/foo/baz/bar
     */
    path?: string;
}

export interface RoleSpecDeny {
    /**
     * AccountAssignments holds the list of account assignments affected by this condition.
     */
    accountAssignments?: outputs.RoleSpecDenyAccountAssignment[];
    /**
     * AppLabels is a map of labels used as part of the RBAC system.
     */
    appLabels?: {[key: string]: string[]};
    /**
     * AppLabelsExpression is a predicate expression used to allow/deny access to Apps.
     */
    appLabelsExpression?: string;
    /**
     * AWSRoleARNs is a list of AWS role ARNs this role is allowed to assume.
     */
    awsRoleArns?: string[];
    /**
     * AzureIdentities is a list of Azure identities this role is allowed to assume.
     */
    azureIdentities?: string[];
    /**
     * ClusterLabels is a map of node labels (used to dynamically grant access to clusters).
     */
    clusterLabels?: {[key: string]: string[]};
    /**
     * ClusterLabelsExpression is a predicate expression used to allow/deny access to remote Teleport clusters.
     */
    clusterLabelsExpression?: string;
    /**
     * DatabaseLabels are used in RBAC system to allow/deny access to databases.
     */
    dbLabels?: {[key: string]: string[]};
    /**
     * DatabaseLabelsExpression is a predicate expression used to allow/deny access to Databases.
     */
    dbLabelsExpression?: string;
    /**
     * DatabaseNames is a list of database names this role is allowed to connect to.
     */
    dbNames?: string[];
    /**
     * DatabasePermissions specifies a set of permissions that will be granted to the database user when using automatic database user provisioning.
     */
    dbPermissions?: outputs.RoleSpecDenyDbPermission[];
    /**
     * DatabaseRoles is a list of databases roles for automatic user creation.
     */
    dbRoles?: string[];
    /**
     * DatabaseServiceLabels are used in RBAC system to allow/deny access to Database Services.
     */
    dbServiceLabels?: {[key: string]: string[]};
    /**
     * DatabaseServiceLabelsExpression is a predicate expression used to allow/deny access to Database Services.
     */
    dbServiceLabelsExpression?: string;
    /**
     * DatabaseUsers is a list of databases users this role is allowed to connect as.
     */
    dbUsers?: string[];
    /**
     * DesktopGroups is a list of groups for created desktop users to be added to
     */
    desktopGroups?: string[];
    /**
     * GCPServiceAccounts is a list of GCP service accounts this role is allowed to assume.
     */
    gcpServiceAccounts?: string[];
    /**
     * GitHubPermissions defines GitHub integration related permissions.
     */
    githubPermissions?: outputs.RoleSpecDenyGithubPermission[];
    /**
     * GroupLabels is a map of labels used as part of the RBAC system.
     */
    groupLabels?: {[key: string]: string[]};
    /**
     * GroupLabelsExpression is a predicate expression used to allow/deny access to user groups.
     */
    groupLabelsExpression?: string;
    /**
     * HostGroups is a list of groups for created users to be added to
     */
    hostGroups?: string[];
    /**
     * HostSudoers is a list of entries to include in a users sudoer file
     */
    hostSudoers?: string[];
    /**
     * Impersonate specifies what users and roles this role is allowed to impersonate by issuing certificates or other possible means.
     */
    impersonate?: outputs.RoleSpecDenyImpersonate;
    /**
     * JoinSessions specifies policies to allow users to join other sessions.
     */
    joinSessions?: outputs.RoleSpecDenyJoinSession[];
    /**
     * KubeGroups is a list of kubernetes groups
     */
    kubernetesGroups?: string[];
    /**
     * KubernetesLabels is a map of kubernetes cluster labels used for RBAC.
     */
    kubernetesLabels?: {[key: string]: string[]};
    /**
     * KubernetesLabelsExpression is a predicate expression used to allow/deny access to kubernetes clusters.
     */
    kubernetesLabelsExpression?: string;
    /**
     * KubernetesResources is the Kubernetes Resources this Role grants access to.
     */
    kubernetesResources?: outputs.RoleSpecDenyKubernetesResource[];
    /**
     * KubeUsers is an optional kubernetes users to impersonate
     */
    kubernetesUsers?: string[];
    /**
     * Logins is a list of *nix system logins.
     */
    logins?: string[];
    /**
     * NodeLabels is a map of node labels (used to dynamically grant access to nodes).
     */
    nodeLabels?: {[key: string]: string[]};
    /**
     * NodeLabelsExpression is a predicate expression used to allow/deny access to SSH nodes.
     */
    nodeLabelsExpression?: string;
    request?: outputs.RoleSpecDenyRequest;
    /**
     * RequireSessionJoin specifies policies for required users to start a session.
     */
    requireSessionJoins?: outputs.RoleSpecDenyRequireSessionJoin[];
    /**
     * ReviewRequests defines conditions for submitting access reviews.
     */
    reviewRequests?: outputs.RoleSpecDenyReviewRequests;
    /**
     * Rules is a list of rules and their access levels. Rules are a high level construct used for access control.
     */
    rules?: outputs.RoleSpecDenyRule[];
    /**
     * SPIFFE is used to allow or deny access to a role holder to generating a SPIFFE SVID.
     */
    spiffes?: outputs.RoleSpecDenySpiffe[];
    /**
     * WindowsDesktopLabels are used in the RBAC system to allow/deny access to Windows desktops.
     */
    windowsDesktopLabels?: {[key: string]: string[]};
    /**
     * WindowsDesktopLabelsExpression is a predicate expression used to allow/deny access to Windows desktops.
     */
    windowsDesktopLabelsExpression?: string;
    /**
     * WindowsDesktopLogins is a list of desktop login names allowed/denied for Windows desktops.
     */
    windowsDesktopLogins?: string[];
    /**
     * WorkloadIdentityLabels controls whether or not specific WorkloadIdentity resources can be invoked. Further authorization controls exist on the WorkloadIdentity resource itself.
     */
    workloadIdentityLabels?: {[key: string]: string[]};
    /**
     * WorkloadIdentityLabelsExpression is a predicate expression used to allow/deny access to issuing a WorkloadIdentity.
     */
    workloadIdentityLabelsExpression?: string;
}

export interface RoleSpecDenyAccountAssignment {
    account?: string;
    permissionSet?: string;
}

export interface RoleSpecDenyDbPermission {
    /**
     * Match is a list of object labels that must be matched for the permission to be granted.
     */
    match?: {[key: string]: string[]};
    /**
     * Permission is the list of string representations of the permission to be given, e.g. SELECT, INSERT, UPDATE, ...
     */
    permissions?: string[];
}

export interface RoleSpecDenyGithubPermission {
    orgs?: string[];
}

export interface RoleSpecDenyImpersonate {
    /**
     * Roles is a list of resources this role is allowed to impersonate
     */
    roles?: string[];
    /**
     * Users is a list of resources this role is allowed to impersonate, could be an empty list or a Wildcard pattern
     */
    users?: string[];
    /**
     * Where specifies optional advanced matcher
     */
    where?: string;
}

export interface RoleSpecDenyJoinSession {
    /**
     * Kinds are the session kinds this policy applies to.
     */
    kinds?: string[];
    /**
     * Modes is a list of permitted participant modes for this policy.
     */
    modes?: string[];
    /**
     * Name is the name of the policy.
     */
    name?: string;
    /**
     * Roles is a list of roles that you can join the session of.
     */
    roles?: string[];
}

export interface RoleSpecDenyKubernetesResource {
    /**
     * Kind specifies the Kubernetes Resource type.
     */
    kind?: string;
    /**
     * Name is the resource name. It supports wildcards.
     */
    name?: string;
    /**
     * Namespace is the resource namespace. It supports wildcards.
     */
    namespace?: string;
    /**
     * Verbs are the allowed Kubernetes verbs for the following resource.
     */
    verbs?: string[];
}

export interface RoleSpecDenyRequest {
    /**
     * Annotations is a collection of annotations to be programmatically appended to pending Access Requests at the time of their creation. These annotations serve as a mechanism to propagate extra information to plugins.  Since these annotations support variable interpolation syntax, they also offer a mechanism for forwarding claims from an external identity provider, to a plugin via `{{external.trait_name}}` style substitutions.
     */
    annotations?: {[key: string]: string[]};
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     */
    claimsToRoles?: outputs.RoleSpecDenyRequestClaimsToRole[];
    /**
     * kubernetes_resources can optionally enforce a requester to request only certain kinds of kube resources. Eg: Users can make request to either a resource kind "kube_cluster" or any of its subresources like "namespaces". This field can be defined such that it prevents a user from requesting "kube_cluster" and enforce requesting any of its subresources.
     */
    kubernetesResources?: outputs.RoleSpecDenyRequestKubernetesResource[];
    /**
     * MaxDuration is the amount of time the access will be granted for. If this is zero, the default duration is used.
     */
    maxDuration?: string;
    /**
     * Reason defines settings for the reason for the access provided by the user.
     */
    reason?: outputs.RoleSpecDenyRequestReason;
    /**
     * Roles is the name of roles which will match the request rule.
     */
    roles?: string[];
    /**
     * SearchAsRoles is a list of extra roles which should apply to a user while they are searching for resources as part of a Resource Access Request, and defines the underlying roles which will be requested as part of any Resource Access Request.
     */
    searchAsRoles?: string[];
    /**
     * SuggestedReviewers is a list of reviewer suggestions.  These can be teleport usernames, but that is not a requirement.
     */
    suggestedReviewers?: string[];
    /**
     * Thresholds is a list of thresholds, one of which must be met in order for reviews to trigger a state-transition.  If no thresholds are provided, a default threshold of 1 for approval and denial is used.
     */
    thresholds?: outputs.RoleSpecDenyRequestThreshold[];
}

export interface RoleSpecDenyRequestClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface RoleSpecDenyRequestKubernetesResource {
    /**
     * kind specifies the Kubernetes Resource type.
     */
    kind?: string;
}

export interface RoleSpecDenyRequestReason {
    /**
     * Mode can be either "required" or "optional". Empty string is treated as "optional". If a role has the request reason mode set to "required", then reason is required for all Access Requests requesting roles or resources allowed by this role. It applies only to users who have this role assigned.
     */
    mode?: string;
}

export interface RoleSpecDenyRequestThreshold {
    /**
     * Approve is the number of matching approvals needed for state-transition.
     */
    approve?: number;
    /**
     * Deny is the number of denials needed for state-transition.
     */
    deny?: number;
    /**
     * Filter is an optional predicate used to determine which reviews count toward this threshold.
     */
    filter?: string;
    /**
     * Name is the optional human-readable name of the threshold.
     */
    name?: string;
}

export interface RoleSpecDenyRequireSessionJoin {
    /**
     * Count is the amount of people that need to be matched for this policy to be fulfilled.
     */
    count?: number;
    /**
     * Filter is a predicate that determines what users count towards this policy.
     */
    filter?: string;
    /**
     * Kinds are the session kinds this policy applies to.
     */
    kinds?: string[];
    /**
     * Modes is the list of modes that may be used to fulfill this policy.
     */
    modes?: string[];
    /**
     * Name is the name of the policy.
     */
    name?: string;
    /**
     * OnLeave is the behaviour that's used when the policy is no longer fulfilled for a live session.
     */
    onLeave?: string;
}

export interface RoleSpecDenyReviewRequests {
    /**
     * ClaimsToRoles specifies a mapping from claims (traits) to teleport roles.
     */
    claimsToRoles?: outputs.RoleSpecDenyReviewRequestsClaimsToRole[];
    /**
     * PreviewAsRoles is a list of extra roles which should apply to a reviewer while they are viewing a Resource Access Request for the purposes of viewing details such as the hostname and labels of requested resources.
     */
    previewAsRoles?: string[];
    /**
     * Roles is the name of roles which may be reviewed.
     */
    roles?: string[];
    /**
     * Where is an optional predicate which further limits which requests are reviewable.
     */
    where?: string;
}

export interface RoleSpecDenyReviewRequestsClaimsToRole {
    /**
     * Claim is a claim name.
     */
    claim?: string;
    /**
     * Roles is a list of static teleport roles to match.
     */
    roles?: string[];
    /**
     * Value is a claim value to match.
     */
    value?: string;
}

export interface RoleSpecDenyRule {
    /**
     * Actions specifies optional actions taken when this rule matches
     */
    actions?: string[];
    /**
     * Resources is a list of resources
     */
    resources?: string[];
    /**
     * Verbs is a list of verbs
     */
    verbs?: string[];
    /**
     * Where specifies optional advanced matcher
     */
    where?: string;
}

export interface RoleSpecDenySpiffe {
    /**
     * DNSSANs specifies matchers for the SPIFFE ID DNS SANs.  Each requested DNS SAN is compared against all matchers configured and if any match, the condition is considered to be met.  The matcher by default allows '*' to be used to indicate zero or more of any character. Prepend '^' and append '$' to instead switch to matching using the Go regex syntax.  Example: *.example.com would match foo.example.com
     */
    dnsSans?: string[];
    /**
     * IPSANs specifies matchers for the SPIFFE ID IP SANs.  Each requested IP SAN is compared against all matchers configured and if any match, the condition is considered to be met.  The matchers should be specified using CIDR notation, it supports IPv4 and IPv6.  Examples: - 10.0.0.0/24 would match 10.0.0.0 to 10.255.255.255 - 10.0.0.42/32 would match only 10.0.0.42
     */
    ipSans?: string[];
    /**
     * Path specifies a matcher for the SPIFFE ID path. It should not include the trust domain and should start with a leading slash.  The matcher by default allows '*' to be used to indicate zero or more of any character. Prepend '^' and append '$' to instead switch to matching using the Go regex syntax.  Example: - /svc/foo/*&#47;bar would match /svc/foo/baz/bar - ^\/svc\/foo\/.*\/bar$ would match /svc/foo/baz/bar
     */
    path?: string;
}

export interface RoleSpecOptions {
    /**
     * CertExtensions specifies the key/values
     */
    certExtensions?: outputs.RoleSpecOptionsCertExtension[];
    /**
     * CertificateFormat defines the format of the user certificate to allow compatibility with older versions of OpenSSH.
     */
    certFormat: string;
    /**
     * ClientIdleTimeout sets disconnect clients on idle timeout behavior, if set to 0 means do not disconnect, otherwise is set to the idle duration.
     */
    clientIdleTimeout?: string;
    /**
     * CreateDatabaseUser enabled automatic database user creation.
     */
    createDbUser?: boolean;
    /**
     * CreateDatabaseUserMode allows users to be automatically created on a database when not set to off. 0 is "unspecified", 1 is "off", 2 is "keep", 3 is "best_effort_drop".
     */
    createDbUserMode?: number;
    /**
     * CreateDesktopUser allows users to be automatically created on a Windows desktop
     */
    createDesktopUser?: boolean;
    /**
     * Deprecated: use CreateHostUserMode instead.
     */
    createHostUser?: boolean;
    /**
     * CreateHostUserDefaultShell is used to configure the default shell for newly provisioned host users.
     */
    createHostUserDefaultShell?: string;
    /**
     * CreateHostUserMode allows users to be automatically created on a host when not set to off. 0 is "unspecified"; 1 is "off"; 2 is "drop" (removed for v15 and above), 3 is "keep"; 4 is "insecure-drop".
     */
    createHostUserMode?: number;
    /**
     * DesktopClipboard indicates whether clipboard sharing is allowed between the user's workstation and the remote desktop. It defaults to true unless explicitly set to false.
     */
    desktopClipboard?: boolean;
    /**
     * DesktopDirectorySharing indicates whether directory sharing is allowed between the user's workstation and the remote desktop. It defaults to false unless explicitly set to true.
     */
    desktopDirectorySharing?: boolean;
    /**
     * DeviceTrustMode is the device authorization mode used for the resources associated with the role. See DeviceTrust.Mode.
     */
    deviceTrustMode?: string;
    /**
     * DisconnectExpiredCert sets disconnect clients on expired certificates.
     */
    disconnectExpiredCert?: boolean;
    /**
     * BPF defines what events to record for the BPF-based session recorder.
     */
    enhancedRecordings: string[];
    /**
     * ForwardAgent is SSH agent forwarding.
     */
    forwardAgent?: boolean;
    /**
     * IDP is a set of options related to accessing IdPs within Teleport. Requires Teleport Enterprise.
     */
    idp?: outputs.RoleSpecOptionsIdp;
    /**
     * Lock specifies the locking mode (strict|best_effort) to be applied with the role.
     */
    lock?: string;
    /**
     * MaxConnections defines the maximum number of concurrent connections a user may hold.
     */
    maxConnections?: number;
    /**
     * MaxKubernetesConnections defines the maximum number of concurrent Kubernetes sessions a user may hold.
     */
    maxKubernetesConnections?: number;
    /**
     * MaxSessionTTL defines how long a SSH session can last for.
     */
    maxSessionTtl: string;
    /**
     * MaxSessions defines the maximum number of concurrent sessions per connection.
     */
    maxSessions?: number;
    /**
     * MFAVerificationInterval optionally defines the maximum duration that can elapse between successive MFA verifications. This variable is used to ensure that users are periodically prompted to verify their identity, enhancing security by preventing prolonged sessions without re-authentication when using tsh proxy * derivatives. It's only effective if the session requires MFA. If not set, defaults to `max_session_ttl`.
     */
    mfaVerificationInterval?: string;
    /**
     * PermitX11Forwarding authorizes use of X11 forwarding.
     */
    permitX11Forwarding?: boolean;
    /**
     * PinSourceIP forces the same client IP for certificate generation and usage
     */
    pinSourceIp?: boolean;
    /**
     * Deprecated: Use SSHPortForwarding instead
     */
    portForwarding?: boolean;
    /**
     * RecordDesktopSession indicates whether desktop access sessions should be recorded. It defaults to true unless explicitly set to false.
     */
    recordSession?: outputs.RoleSpecOptionsRecordSession;
    /**
     * RequestAccess defines the request strategy (optional|reason|always) where optional is the default.
     */
    requestAccess?: string;
    /**
     * RequestPrompt is an optional message which tells users what they aught to request.
     */
    requestPrompt?: string;
    /**
     * RequireMFAType is the type of MFA requirement enforced for this user. 0 is "OFF", 1 is "SESSION", 2 is "SESSION_AND_HARDWARE_KEY", 3 is "HARDWARE_KEY_TOUCH", 4 is "HARDWARE_KEY_PIN", 5 is "HARDWARE_KEY_TOUCH_AND_PIN".
     */
    requireSessionMfa?: number;
    /**
     * SSHFileCopy indicates whether remote file operations via SCP or SFTP are allowed over an SSH session. It defaults to true unless explicitly set to false.
     */
    sshFileCopy?: boolean;
    /**
     * SSHPortForwarding configures what types of SSH port forwarding are allowed by a role.
     */
    sshPortForwarding?: outputs.RoleSpecOptionsSshPortForwarding;
}

export interface RoleSpecOptionsCertExtension {
    /**
     * Mode is the type of extension to be used -- currently critical-option is not supported. 0 is "extension".
     */
    mode?: number;
    /**
     * Name specifies the key to be used in the cert extension.
     */
    name?: string;
    /**
     * Type represents the certificate type being extended, only ssh is supported at this time. 0 is "ssh".
     */
    type?: number;
    /**
     * Value specifies the value to be used in the cert extension.
     */
    value?: string;
}

export interface RoleSpecOptionsIdp {
    /**
     * SAML are options related to the Teleport SAML IdP.
     */
    saml?: outputs.RoleSpecOptionsIdpSaml;
}

export interface RoleSpecOptionsIdpSaml {
    /**
     * Enabled is set to true if this option allows access to the Teleport SAML IdP.
     */
    enabled?: boolean;
}

export interface RoleSpecOptionsRecordSession {
    /**
     * Default indicates the default value for the services.
     */
    default?: string;
    /**
     * Desktop indicates whether desktop sessions should be recorded. It defaults to true unless explicitly set to false.
     */
    desktop?: boolean;
    /**
     * SSH indicates the session mode used on SSH sessions.
     */
    ssh?: string;
}

export interface RoleSpecOptionsSshPortForwarding {
    /**
     * Allow local port forwarding.
     */
    local?: outputs.RoleSpecOptionsSshPortForwardingLocal;
    /**
     * Allow remote port forwarding.
     */
    remote?: outputs.RoleSpecOptionsSshPortForwardingRemote;
}

export interface RoleSpecOptionsSshPortForwardingLocal {
    enabled?: boolean;
}

export interface RoleSpecOptionsSshPortForwardingRemote {
    enabled?: boolean;
}

export interface SamlConnectorMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface SamlConnectorSpec {
    /**
     * AssertionConsumerService is a URL for assertion consumer service on the service provider (Teleport's side).
     */
    acs: string;
    /**
     * AllowIDPInitiated is a flag that indicates if the connector can be used for IdP-initiated logins.
     */
    allowIdpInitiated?: boolean;
    /**
     * EncryptionKeyPair is a key pair used for decrypting SAML assertions.
     */
    assertionKeyPair?: outputs.SamlConnectorSpecAssertionKeyPair;
    /**
     * AttributesToRoles is a list of mappings of attribute statements to roles.
     */
    attributesToRoles: outputs.SamlConnectorSpecAttributesToRole[];
    /**
     * Audience uniquely identifies our service provider.
     */
    audience: string;
    /**
     * Cert is the identity provider certificate PEM. IDP signs `<Response>` responses using this certificate.
     */
    cert?: string;
    /**
     * ClientRedirectSettings defines which client redirect URLs are allowed for non-browser SSO logins other than the standard localhost ones.
     */
    clientRedirectSettings?: outputs.SamlConnectorSpecClientRedirectSettings;
    /**
     * Display controls how this connector is displayed.
     */
    display?: string;
    /**
     * EntityDescriptor is XML with descriptor. It can be used to supply configuration parameters in one XML file rather than supplying them in the individual elements.
     */
    entityDescriptor?: string;
    /**
     * EntityDescriptorURL is a URL that supplies a configuration XML.
     */
    entityDescriptorUrl?: string;
    /**
     * ForceAuthn specified whether re-authentication should be forced on login. UNSPECIFIED is treated as NO.
     */
    forceAuthn?: number;
    /**
     * Issuer is the identity provider issuer.
     */
    issuer: string;
    /**
     * MFASettings contains settings to enable SSO MFA checks through this auth connector.
     */
    mfa?: outputs.SamlConnectorSpecMfa;
    /**
     * Provider is the external identity provider.
     */
    provider?: string;
    /**
     * ServiceProviderIssuer is the issuer of the service provider (Teleport).
     */
    serviceProviderIssuer: string;
    /**
     * SigningKeyPair is an x509 key pair used to sign AuthnRequest.
     */
    signingKeyPair: outputs.SamlConnectorSpecSigningKeyPair;
    /**
     * SingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out). If this is not provided, SLO is disabled.
     */
    singleLogoutUrl?: string;
    /**
     * SSO is the URL of the identity provider's SSO service.
     */
    sso: string;
}

export interface SamlConnectorSpecAssertionKeyPair {
    /**
     * Cert is a PEM-encoded x509 certificate.
     */
    cert: string;
    /**
     * PrivateKey is a PEM encoded x509 private key.
     */
    privateKey: string;
}

export interface SamlConnectorSpecAttributesToRole {
    /**
     * Name is an attribute statement name.
     */
    name?: string;
    /**
     * Roles is a list of static teleport roles to map to.
     */
    roles?: string[];
    /**
     * Value is an attribute statement value to match.
     */
    value?: string;
}

export interface SamlConnectorSpecClientRedirectSettings {
    /**
     * a list of hostnames allowed for https client redirect URLs
     */
    allowedHttpsHostnames?: string[];
    /**
     * a list of CIDRs allowed for HTTP or HTTPS client redirect URLs
     */
    insecureAllowedCidrRanges?: string[];
}

export interface SamlConnectorSpecMfa {
    /**
     * Cert is the identity provider certificate PEM. IDP signs `<Response>` responses using this certificate.
     */
    cert?: string;
    /**
     * Enabled specified whether this SAML connector supports MFA checks. Defaults to false.
     */
    enabled?: boolean;
    /**
     * EntityDescriptor is XML with descriptor. It can be used to supply configuration parameters in one XML file rather than supplying them in the individual elements. Usually set from EntityDescriptorUrl.
     */
    entityDescriptor?: string;
    /**
     * EntityDescriptorUrl is a URL that supplies a configuration XML.
     */
    entityDescriptorUrl?: string;
    /**
     * ForceAuthn specified whether re-authentication should be forced for MFA checks. UNSPECIFIED is treated as YES to always re-authentication for MFA checks. This should only be set to NO if the IdP is setup to perform MFA checks on top of active user sessions.
     */
    forceAuthn?: number;
    /**
     * Issuer is the identity provider issuer. Usually set from EntityDescriptor.
     */
    issuer?: string;
    /**
     * SSO is the URL of the identity provider's SSO service. Usually set from EntityDescriptor.
     */
    sso?: string;
}

export interface SamlConnectorSpecSigningKeyPair {
    /**
     * Cert is a PEM-encoded x509 certificate.
     */
    cert: string;
    /**
     * PrivateKey is a PEM encoded x509 private key.
     */
    privateKey: string;
}

export interface ServerMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface ServerSpec {
    /**
     * Addr is a host:port address where this server can be reached.
     */
    addr?: string;
    /**
     * CloudMetadata contains info about the cloud instance the server is running on, if any.
     */
    cloudMetadata?: outputs.ServerSpecCloudMetadata;
    /**
     * GitHub contains info about GitHub proxies where each server represents a GitHub organization.
     */
    github?: outputs.ServerSpecGithub;
    /**
     * Hostname is server hostname
     */
    hostname?: string;
    /**
     * PeerAddr is the address a proxy server is reachable at by its peer proxies.
     */
    peerAddr?: string;
    /**
     * ProxyIDs is a list of proxy IDs this server is expected to be connected to.
     */
    proxyIds?: string[];
    /**
     * PublicAddrs is a list of public addresses where this server can be reached.
     */
    publicAddrs?: string[];
    /**
     * Rotation specifies server rotation
     */
    rotation?: outputs.ServerSpecRotation;
    /**
     * UseTunnel indicates that connections to this server should occur over a reverse tunnel.
     */
    useTunnel?: boolean;
    /**
     * TeleportVersion is the teleport version that the server is running on
     */
    version?: string;
}

export interface ServerSpecCloudMetadata {
    /**
     * AWSInfo contains attributes to match to an EC2 instance.
     */
    aws?: outputs.ServerSpecCloudMetadataAws;
}

export interface ServerSpecCloudMetadataAws {
    /**
     * AccountID is an AWS account ID.
     */
    accountId?: string;
    /**
     * InstanceID is an EC2 instance ID.
     */
    instanceId?: string;
    /**
     * Integration is the integration name that added this Node. When connecting to it, it will use this integration to issue AWS API calls in order to set up the connection. This includes sending an SSH Key and then opening a tunnel (EC2 Instance Connect Endpoint) so Teleport can connect to it.
     */
    integration?: string;
    /**
     * Region is the AWS EC2 Instance Region.
     */
    region?: string;
    /**
     * SubnetID is the Subnet ID in use by the instance.
     */
    subnetId?: string;
    /**
     * VPCID is the AWS VPC ID where the Instance is running.
     */
    vpcId?: string;
}

export interface ServerSpecGithub {
    /**
     * Integration is the integration that is associated with this Server.
     */
    integration?: string;
    /**
     * Organization specifies the name of the organization for the GitHub integration.
     */
    organization?: string;
}

export interface ServerSpecRotation {
    /**
     * CurrentID is the ID of the rotation operation to differentiate between rotation attempts.
     */
    currentId?: string;
    /**
     * GracePeriod is a period during which old and new CA are valid for checking purposes, but only new CA is issuing certificates.
     */
    gracePeriod?: string;
    /**
     * LastRotated specifies the last time of the completed rotation.
     */
    lastRotated?: string;
    /**
     * Mode sets manual or automatic rotation mode.
     */
    mode?: string;
    /**
     * Phase is the current rotation phase.
     */
    phase?: string;
    /**
     * Schedule is a rotation schedule - used in automatic mode to switch between phases.
     */
    schedule?: outputs.ServerSpecRotationSchedule;
    /**
     * Started is set to the time when rotation has been started in case if the state of the rotation is "in_progress".
     */
    started?: string;
    /**
     * State could be one of "init" or "in_progress".
     */
    state?: string;
}

export interface ServerSpecRotationSchedule {
    /**
     * Standby specifies time to switch to the "Standby" phase.
     */
    standby?: string;
    /**
     * UpdateClients specifies time to switch to the "Update clients" phase
     */
    updateClients?: string;
    /**
     * UpdateServers specifies time to switch to the "Update servers" phase.
     */
    updateServers?: string;
}

export interface SessionRecordingConfigMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface SessionRecordingConfigSpec {
    /**
     * Mode controls where (or if) the session is recorded.
     */
    mode: string;
    /**
     * ProxyChecksHostKeys is used to control if the proxy will check host keys when in recording mode.
     */
    proxyChecksHostKeys?: boolean;
}

export interface StaticHostUserMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface StaticHostUserSpec {
    matchers: outputs.StaticHostUserSpecMatcher[];
}

export interface StaticHostUserSpecMatcher {
    /**
     * default_shell is the new user's default shell
     */
    defaultShell?: string;
    /**
     * gid is the new user's gid.
     */
    gid?: number;
    /**
     * groups is a list of additional groups to add the user to.
     */
    groups?: string[];
    /**
     * node_labels is a map of node labels that will create a user from this resource.
     */
    nodeLabels?: outputs.StaticHostUserSpecMatcherNodeLabel[];
    /**
     * node_labels_expression is a predicate expression to create a user from this resource.
     */
    nodeLabelsExpression?: string;
    /**
     * sudoers is a list of sudoer entries to add.
     */
    sudoers?: string[];
    /**
     * take_ownership_if_user_exists will take ownership of existing, unmanaged users
     */
    takeOwnershipIfUserExists?: boolean;
    /**
     * uid is the new user's uid.
     */
    uid?: number;
}

export interface StaticHostUserSpecMatcherNodeLabel {
    /**
     * The name of the label.
     */
    name: string;
    /**
     * The values associated with the label.
     */
    values: string[];
}

export interface TrustedClusterMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface TrustedClusterSpec {
    /**
     * Enabled is a bool that indicates if the TrustedCluster is enabled or disabled. Setting Enabled to false has a side effect of deleting the user and host certificate authority (CA).
     */
    enabled?: boolean;
    /**
     * RoleMap specifies role mappings to remote roles.
     */
    roleMaps?: outputs.TrustedClusterSpecRoleMap[];
    /**
     * Roles is a list of roles that users will be assuming when connecting to this cluster.
     */
    roles?: string[];
    /**
     * Token is the authorization token provided by another cluster needed by this cluster to join.
     */
    token?: string;
    /**
     * ReverseTunnelAddress is the address of the SSH proxy server of the cluster to join. If not set, it is derived from `<metadata.name>:<default reverse tunnel port>`.
     */
    tunnelAddr?: string;
    /**
     * ProxyAddress is the address of the web proxy server of the cluster to join. If not set, it is derived from `<metadata.name>:<default web proxy server port>`.
     */
    webProxyAddr?: string;
}

export interface TrustedClusterSpecRoleMap {
    /**
     * Local specifies local roles to map to
     */
    locals?: string[];
    /**
     * Remote specifies remote role name to map from
     */
    remote?: string;
}

export interface TrustedDeviceMetadata {
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name?: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface TrustedDeviceSpec {
    assetTag: string;
    enrollStatus: string;
    osType: string;
    owner?: string;
    source?: outputs.TrustedDeviceSpecSource;
}

export interface TrustedDeviceSpecSource {
    name?: string;
    origin?: string;
}

export interface UserMetadata {
    /**
     * Description is object description
     */
    description?: string;
    /**
     * Expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * Labels is a set of labels
     */
    labels?: {[key: string]: string};
    /**
     * Name is an object name
     */
    name: string;
    /**
     * Namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * Revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface UserSpec {
    /**
     * GithubIdentities list associated Github OAuth2 identities that let user log in using externally verified identity
     */
    githubIdentities?: outputs.UserSpecGithubIdentity[];
    /**
     * OIDCIdentities lists associated OpenID Connect identities that let user log in using externally verified identity
     */
    oidcIdentities?: outputs.UserSpecOidcIdentity[];
    /**
     * Roles is a list of roles assigned to user
     */
    roles?: string[];
    /**
     * SAMLIdentities lists associated SAML identities that let user log in using externally verified identity
     */
    samlIdentities?: outputs.UserSpecSamlIdentity[];
    /**
     * Traits are key/value pairs received from an identity provider (through OIDC claims or SAML assertions) or from a system administrator for local accounts. Traits are used to populate role variables.
     */
    traits?: {[key: string]: string[]};
    /**
     * TrustedDeviceIDs contains the IDs of trusted devices enrolled by the user.  Note that SSO users are transient and thus may contain an empty TrustedDeviceIDs field, even though the user->device association exists under the Device Trust subsystem. Do not rely on this field to determine device associations or ownership, it exists for legacy/informative purposes only.  Managed by the Device Trust subsystem, avoid manual edits.
     */
    trustedDeviceIds?: string[];
}

export interface UserSpecGithubIdentity {
    /**
     * ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
     */
    connectorId?: string;
    /**
     * SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
     */
    samlSingleLogoutUrl?: string;
    /**
     * UserID is the ID of the identity. Some connectors like GitHub have an unique ID apart from the username.
     */
    userId?: string;
    /**
     * Username is username supplied by external identity provider
     */
    username?: string;
}

export interface UserSpecOidcIdentity {
    /**
     * ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
     */
    connectorId?: string;
    /**
     * SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
     */
    samlSingleLogoutUrl?: string;
    /**
     * UserID is the ID of the identity. Some connectors like GitHub have an unique ID apart from the username.
     */
    userId?: string;
    /**
     * Username is username supplied by external identity provider
     */
    username?: string;
}

export interface UserSpecSamlIdentity {
    /**
     * ConnectorID is id of registered OIDC connector, e.g. 'google-example.com'
     */
    connectorId?: string;
    /**
     * SAMLSingleLogoutURL is the SAML Single log-out URL to initiate SAML SLO (single log-out), if applicable.
     */
    samlSingleLogoutUrl?: string;
    /**
     * UserID is the ID of the identity. Some connectors like GitHub have an unique ID apart from the username.
     */
    userId?: string;
    /**
     * Username is username supplied by external identity provider
     */
    username?: string;
}

export interface UserStatus {
    /**
     * mfa_weakest_device reflects what the system knows about the user's weakest MFA device. Note that this is a "best effort" property, in that it can be UNSPECIFIED.
     */
    mfaWeakestDevice?: number;
    /**
     * password_state reflects what the system knows about the user's password. Note that this is a "best effort" property, in that it can be UNSPECIFIED for users who were created before this property was introduced and didn't perform any password-related activity since then. See RFD 0159 for details. Do NOT use this value for authentication purposes!
     */
    passwordState?: number;
}

export interface WorkloadIdentityMetadata {
    /**
     * description is object description.
     */
    description?: string;
    /**
     * expires is a global expiry time header can be set on any resource in the system.
     */
    expires?: string;
    /**
     * labels is a set of labels.
     */
    labels?: {[key: string]: string};
    /**
     * name is an object name.
     */
    name?: string;
    /**
     * namespace is object namespace. The field should be called "namespace" when it returns in Teleport 2.4.
     */
    namespace: string;
    /**
     * revision is an opaque identifier which tracks the versions of a resource over time. Clients should ignore and not alter its value but must return the revision in any updates of a resource.
     */
    revision?: string;
}

export interface WorkloadIdentitySpec {
    /**
     * The rules which are evaluated before the WorkloadIdentity can be issued.
     */
    rules?: outputs.WorkloadIdentitySpecRules;
    /**
     * Configuration pertaining to the issuance of SPIFFE-compatible workload identity credentials.
     */
    spiffe?: outputs.WorkloadIdentitySpecSpiffe;
}

export interface WorkloadIdentitySpecRules {
    /**
     * A list of rules used to determine if a WorkloadIdentity can be issued. If none are provided, it will be considered a pass. If any are provided, then at least one must pass for the rules to be considered passed.
     */
    allows?: outputs.WorkloadIdentitySpecRulesAllow[];
}

export interface WorkloadIdentitySpecRulesAllow {
    /**
     * The conditions that must be met for this rule to be considered passed.  Mutually exclusive with expression.
     */
    conditions?: outputs.WorkloadIdentitySpecRulesAllowCondition[];
    /**
     * An expression written in Teleport's predicate language that must evaluate to true for this rule to be considered passed.  Mutually exclusive with conditions.
     */
    expression?: string;
}

export interface WorkloadIdentitySpecRulesAllowCondition {
    /**
     * The name of the attribute to evaluate the condition against.
     */
    attribute?: string;
    /**
     * The attribute casted to a string must be equal to the value.
     */
    eq?: outputs.WorkloadIdentitySpecRulesAllowConditionEq;
    /**
     * The attribute casted to a string must be in the list of values.
     */
    in?: outputs.WorkloadIdentitySpecRulesAllowConditionIn;
    /**
     * The attribute casted to a string must not be equal to the value.
     */
    notEq?: outputs.WorkloadIdentitySpecRulesAllowConditionNotEq;
    /**
     * The attribute casted to a string must not be in the list of values.
     */
    notIn?: outputs.WorkloadIdentitySpecRulesAllowConditionNotIn;
}

export interface WorkloadIdentitySpecRulesAllowConditionEq {
    /**
     * The value to compare the attribute against.
     */
    value?: string;
}

export interface WorkloadIdentitySpecRulesAllowConditionIn {
    /**
     * The list of values to compare the attribute against.
     */
    values?: string[];
}

export interface WorkloadIdentitySpecRulesAllowConditionNotEq {
    /**
     * The value to compare the attribute against.
     */
    value?: string;
}

export interface WorkloadIdentitySpecRulesAllowConditionNotIn {
    /**
     * The list of values to compare the attribute against.
     */
    values?: string[];
}

export interface WorkloadIdentitySpecSpiffe {
    /**
     * A freeform text field which is provided to workloads along with a credential produced by this WorkloadIdentity. This can be used to provide additional context that can be used to select between multiple credentials.
     */
    hint?: string;
    /**
     * The path of the SPIFFE ID that will be issued to the workload.  This should be prefixed with a forward-slash ("/").  This field supports templating using attributes.
     */
    id?: string;
    /**
     * Configuration specific to JWT-SVIDs.
     */
    jwt?: outputs.WorkloadIdentitySpecSpiffeJwt;
    /**
     * Configuration specific to X509-SVIDs.
     */
    x509?: outputs.WorkloadIdentitySpecSpiffeX509;
}

export interface WorkloadIdentitySpecSpiffeJwt {
    /**
     * Control the maximum TTL of JWT-SVIDs issued using this WorkloadIdentity.  If a JWT-SVID is requested with a TTL greater than this value, then the returned JWT-SVID will have a TTL of this value.  Defaults to 24 hours. The maximum this value can be set to is 24 hours.
     */
    maximumTtl?: string;
}

export interface WorkloadIdentitySpecSpiffeX509 {
    /**
     * The DNS Subject Alternative Names (SANs) that should be included in an X509-SVID issued using this WorkloadIdentity.  Each entry in this list supports templating using attributes.
     */
    dnsSans?: string[];
    /**
     * Control the maximum TTL of X509-SVIDs issued using this WorkloadIdentity.  If a X509-SVID is requested with a TTL greater than this value, then the returned X509-SVID will have a TTL of this value.  Defaults to 24 hours. The maximum this value can be set to is 14 days.
     */
    maximumTtl?: string;
    /**
     * Used to configure the Subject Distinguished Name (DN) of the X509-SVID.  In most circumstances, it is recommended to prefer relying on the SPIFFE ID encoded in the URI SAN. However, the Subject DN may be needed to support legacy systems designed for X509 and not SPIFFE/WIMSE.  If not provided, the X509-SVID will be issued with an empty Subject DN.
     */
    subjectTemplate?: outputs.WorkloadIdentitySpecSpiffeX509SubjectTemplate;
}

export interface WorkloadIdentitySpecSpiffeX509SubjectTemplate {
    /**
     * Common Name (CN) - 2.5.4.3 If empty, the RDN will be omitted from the DN.
     */
    commonName?: string;
    /**
     * Organization (O) - 2.5.4.10 If empty, the RDN will be omitted from the DN.
     */
    organization?: string;
    /**
     * Organizational Unit (OU) - 2.5.4.11 If empty, the RDN will be omitted from the DN.
     */
    organizationalUnit?: string;
}

